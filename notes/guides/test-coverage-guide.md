# Test Coverage Guide

This guide explains how to use test coverage reporting in the Topos compiler project.

## Overview

Test coverage measures how much of the source code is executed during testing. The Topos project uses Erlang's built-in `cover` tool to track line coverage for all type system modules.

## Quick Start

### Run Tests with Coverage

```bash
make coverage
```

This will:
1. Compile all source and test modules
2. Run the complete test suite with coverage tracking
3. Generate HTML coverage reports in `_build/test/cover/`
4. Display a coverage summary in the terminal

### View Coverage Summary

After running coverage, view the summary:

```bash
make coverage-report
```

### Open HTML Reports

Detailed line-by-line coverage reports are generated as HTML:

```bash
# On Linux
xdg-open _build/test/cover/topos_types.html

# On macOS
open _build/test/cover/topos_types.html

# On Windows
start _build/test/cover/topos_types.html
```

## Interpreting Coverage Results

### Coverage Percentage

- **80-100%**: Excellent coverage (shown in green)
- **60-79%**: Good coverage (shown in yellow)
- **0-59%**: Needs improvement (shown in red)

### What Coverage Means

- **Covered line**: Executed at least once during tests
- **Uncovered line**: Never executed during tests
- **100% coverage ≠ bug-free**: Coverage measures execution, not correctness

## Coverage Targets

The type system modules aim for:

- **Core modules** (topos_types, topos_type_subst, topos_type_scheme): ≥95%
- **Utility modules** (topos_type_pp, topos_type_env): ≥90%
- **Error handling** (topos_type_error): ≥80%
- **Integration modules** (topos_compiler_utils): ≥75%

## Excluded Modules

The following modules are excluded from coverage reporting:

- **topos_lexer_gen**: Auto-generated by leex
- **topos_parser**: Auto-generated by yecc

These are excluded because:
1. Generated code is not manually written or maintained
2. Testing the generators themselves is more valuable than coverage
3. Parser/lexer correctness is validated through integration tests

## Running Coverage for Specific Modules

To run coverage for a single test module:

```bash
./scripts/run_coverage.sh topos_types_tests
```

## Manual Coverage Analysis

For advanced users, you can use Erlang's cover tool directly:

```erlang
% Start Erlang shell with compiled modules
erl -pa _build/test

% In the shell:
1> cover:start().
2> cover:compile_beam(topos_types).
3> topos_types_tests:test().
4> cover:analyse_to_file(topos_types, "_build/test/cover/topos_types.html", [html]).
5> cover:analyse(topos_types, coverage, line).
```

## Improving Coverage

### Identifying Uncovered Code

1. Run coverage: `make coverage`
2. Open HTML report for module with low coverage
3. Red-highlighted lines indicate uncovered code
4. Green-highlighted lines indicate covered code

### Common Reasons for Low Coverage

1. **Error paths not tested**: Add negative test cases
2. **Edge cases missed**: Add boundary value tests
3. **Defensive code**: Code that handles "impossible" cases
4. **Dead code**: Remove unused code paths

### Adding Tests for Uncovered Code

**Example**: If `topos_types:tvariant/1` has low coverage:

```erlang
% In test/compiler/types/topos_types_tests.erl
test_variant_construction() ->
    % Test single constructor
    V1 = topos_types:tvariant([{none, []}]),
    ?assertMatch({tvariant, [{none, []}]}, V1),

    % Test multiple constructors
    IntType = topos_types:tcon(integer),
    V2 = topos_types:tvariant([
        {some, [IntType]},
        {none, []}
    ]),
    ?assertMatch({tvariant, [{some, _}, {none, []}]}, V2).
```

## Coverage in CI/CD

### GitHub Actions Example

```yaml
- name: Run tests with coverage
  run: make coverage

- name: Check coverage threshold
  run: |
    # Fail if coverage drops below 80%
    COVERAGE=$(./scripts/coverage_summary.sh | grep "Overall" | awk '{print $2}' | tr -d '%')
    if [ "$COVERAGE" -lt 80 ]; then
      echo "Coverage $COVERAGE% is below threshold 80%"
      exit 1
    fi
```

## Coverage Reports in Pull Requests

When submitting PRs, include coverage information:

1. Run `make coverage`
2. Note the coverage percentage for modified modules
3. Include in PR description:
   ```
   ## Test Coverage
   - topos_types: 96% (+2%)
   - topos_type_subst: 94% (unchanged)
   - topos_type_scheme: 91% (+5%)
   ```

## Troubleshooting

### "No coverage data found"

**Problem**: Running `make coverage-report` without running tests first.

**Solution**: Run `make coverage` first to generate coverage data.

### Low coverage despite many tests

**Problem**: Tests run but don't execute all code paths.

**Causes**:
- Tests focus on happy path only
- Missing edge case tests
- Dead code that should be removed

**Solution**: Review HTML coverage report to identify untested paths.

### Coverage report shows 0% for all modules

**Problem**: Cover tool didn't instrument modules correctly.

**Solution**:
1. Clean and rebuild: `make clean && make coverage`
2. Verify modules compile: Check `_build/test/*.beam` exists
3. Check for compilation errors in the output

## Best Practices

### Write Tests First (TDD)

1. Write failing test
2. Run coverage to see new uncovered code
3. Implement feature
4. Run coverage to verify code is now covered

### Test Behavior, Not Implementation

Focus on testing the module's API and behavior, not internal details:

```erlang
% Good: Tests observable behavior
test_substitution_removes_variable() ->
    S = topos_type_subst:singleton(1, topos_types:tcon(integer)),
    T = topos_types:tvar(1),
    Result = topos_type_subst:apply(S, T),
    ?assertEqual(topos_types:tcon(integer), Result).

% Avoid: Tests internal representation details
```

### Maintain Coverage Over Time

- Check coverage before committing
- Don't submit PRs that decrease overall coverage
- Add tests for bug fixes to prevent regressions

## Resources

- [Erlang cover Documentation](https://www.erlang.org/doc/man/cover.html)
- [EUnit Testing Guide](https://www.erlang.org/doc/apps/eunit/chapter.html)
- Project test structure: `test/compiler/types/`

## Coverage Goals by Phase

### Phase 1 (Current): Type System
- **Target**: ≥90% overall coverage
- **Focus**: Core type operations, substitution, unification

### Phase 2: REPL and Runtime
- **Target**: ≥85% overall coverage
- **Focus**: User-facing features, error messages

### Phase 3: Pattern Matching
- **Target**: ≥90% overall coverage
- **Focus**: Exhaustiveness checking, redundancy detection

### Phase 4: Module System
- **Target**: ≥85% overall coverage
- **Focus**: Module resolution, signature checking

### Phase 5: Actor Model
- **Target**: ≥80% overall coverage
- **Focus**: Process lifecycle, message handling
