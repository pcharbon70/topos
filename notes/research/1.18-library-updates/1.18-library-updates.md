Integrating Igniter-Like Code Generators into the Language
Introduction

Designing our new functional language (provisionally called Topos) on the BEAM VM involves exploring innovative features that improve developer experience. One such idea is inspired by Elixir’s Igniter library – a code generation and project patching toolkit. Igniter helps library authors automate the integration of their libraries into user projects by modifying code (adding configuration, new modules, etc.) through AST transformations
elixirmerge.com
. The goal here is to evaluate how a similar concept could be built into Topos either as a language feature or as part of its tooling, while aligning with Topos’s category-theoretic, functional design principles.

Overview: What Igniter and Sourceror Do

Igniter is essentially a framework for semantically generating and modifying code in Elixir projects
github.com
. Instead of naive text find-and-replace, Igniter parses source code into an Abstract Syntax Tree (AST) and applies transformations, ensuring consistency and correctness of code edits
elixirmerge.com
. This approach avoids the pitfalls of traditional code generators (which can leave stale config entries or require manual fixes) by working at the AST level
elixirmerge.com
. Under the hood, Igniter uses Sourceror, a library that can parse Elixir code to AST and print it back out. Sourceror enables writing “codemods” – automated code modifications – by manipulating the AST and converting it back to source code
hexdocs.pm
. For example, one can programmatically replace all calls to a deprecated function with a new one in the codebase using Sourceror
hexdocs.pm
. Crucially, these AST-based edits preserve code structure and formatting as much as possible, often by computing minimal text patches rather than reprinting entire files
hexdocs.pm
.

Igniter provides a high-level project patching API on top of Sourceror. It offers pipeline-style functions to create files, insert code, and update configurations in a declarative manner
hexdocs.pm
hexdocs.pm
. For instance, an Igniter generator might create a new module file and ensure the project’s config includes a reference to that module (e.g. adding an item to a list in config.exs)
hexdocs.pm
hexdocs.pm
. The changes are presented as a diff for review before being applied
hexdocs.pm
, promoting transparency. Overall, Igniter’s design emphasizes modifying ASTs rather than raw text to achieve greater consistency in generated code
elixirmerge.com
. It tackles problems like stale or manually-edited configuration files by systematically applying updates (using a builder pattern and a high-level project API) so that adding a library is reproducible and scriptable rather than a manual process
elixirmerge.com
.

For end-users, Igniter provides convenient Mix tasks (commands) such as mix igniter.install and mix igniter.upgrade. The install task can automatically add a dependency to the project and run that library’s installer script, handling all required code insertions
github.com
. The upgrade task goes beyond a normal deps.update by also running any upgrade patchers the library defines, thereby updating the user’s code to accommodate breaking changes or deprecations
github.com
. There are also refactoring tasks (e.g. renaming a function across a codebase) that end-users can invoke on their own code
github.com
 – effectively a form of general codemod.

For library authors, Igniter offers a toolkit to write these generator and patcher tasks. Authors can create a special Mix task (for example my_lib.install) that describes how to configure a project when their library is installed
github.com
. Igniter will detect and run this automatically during installation of the library
github.com
. Similarly, authors can provide version-specific patch scripts that the upgrade mechanism uses. All of this is done via a declarative API – authors use Igniter’s functions to express “add this dependency, create these files, insert this code snippet in module X, update this config list, etc.” rather than manually emitting text. The Igniter tasks are composable as well, meaning one generator can call or include another
github.com
github.com
. This composability aligns with functional design: complex transformations are built by composing simpler ones (much like composing morphisms in category theory). The result is a more maintainable and consistent integration process, as each library carries its own recipes for setup and updates.

Does It Belong in the Language or Tooling?

The key question is whether Topos should incorporate an Igniter-like system as a first-class language feature or provide it as part of the tooling (package manager/build tool). We consider both approaches:

Language-Level Integration: Integrating these capabilities into the language means the compiler or runtime is aware of library installation hooks and codegen. This could involve a specialized section in a library’s code (or metadata) that the compiler executes at install/update time. For example, Topos could allow libraries to declare module registration hooks in a declarative form as part of the package. The language’s package manager or compiler could then automatically run a library’s setup code when the library is added, an upgrade code when the version changes, and a teardown code if the library is removed. Making it language-level ensures a standard, uniform mechanism for all libraries. It also means the feature can be designed with Topos’s semantics in mind (e.g. ensuring purity, controlling side effects during codegen, and aligning with category-theoretic abstractions). However, this approach increases the complexity of the compiler/build system. We’d be, in effect, building a mini project transformer into the language. Care must be taken to sandbox or clearly delineate these meta-operations so they don’t violate the language’s safety guarantees. (For instance, running arbitrary code on library install could be a security risk, so it might need user confirmation or some permissions model.)

Tooling/Ecosystem Integration: The alternative is to implement Igniter’s concept in Topos’s package manager or CLI tool, rather than in the core language semantics. This would be analogous to how Elixir uses Mix tasks – the language itself isn’t aware of Igniter; it’s an external library and tool. Topos could ship with an official tool (say, a topos command) that has subcommands like topos install <pkg> or topos upgrade <pkg>. Under the hood, these commands would look for scripts or metadata provided by the library and apply code patches to the user’s project. This approach keeps the core language simpler (no need to alter the compiler to support codegen hooks), while still providing the functionality at the ecosystem level. It also might be easier to iterate on and update separately from the language specification. The downside is a slightly less “magical” integration – developers have to know to run the tool commands (though it could perhaps be automated when adding deps). It might also be less tightly coupled with language features (for example, error messages or type checking of the generator scripts might not be as robust as if it were in language).

Evaluating these approaches: Given Topos’s emphasis on category theory and likely preference for clarity and correctness, a language-integrated solution could enforce more structure on these code modifications. On the other hand, code generation and project mutation are inherently side-effectful operations (they change the user’s source code), which typically lies outside the pure functional core of a language. In category-theoretic terms, one might model the entire codebase as an object in a category and the code transformations as morphisms. These transformations compose (one after the other) to yield a final codebase state, which is conceptually neat. But it might be wise to treat these as meta-level operations rather than ordinary functions within the language, since they operate on the program’s source, not within the program’s execution domain.

Given that currently our language design only includes an AST parser at build time (and no built-in facility for arbitrary codemods), adding a full Igniter-like system would be a significant new feature. It might make sense to start as a tooling feature (for example, a topos-gen utility or enhancements to the package manager) and later consider deeper integration if needed. This is similar to how Igniter itself is an external library in Elixir – albeit a very powerful one – rather than a part of the Elixir compiler.

Designing a Declarative Library Integration Mechanism

If we pursue this concept, whether via core language or tooling, we should design a declarative, version-aware module registration system for libraries. Here’s an outline of how such a system could work in Topos:

Library Metadata for Hooks: Each package can include a manifest (for example, LibraryHooks module or a package.toml section) that declares optional hooks: on_install, on_update, and on_remove (or setup, upgrade, teardown). These hooks could be version-aware. For instance, a library might specify: “on_update from 1.x to 2.0, execute migration X; on_update from 2.x to 3.0, execute migration Y.” This allows handling breaking changes between specific versions. The system can apply all relevant migrations sequentially when upgrading multiple versions (e.g. if jumping from 1.0 to 3.0, run the 2.0 migration then 3.0 migration).

Declarative vs Programmatic: We envision a declarative DSL for these hooks. Rather than writing low-level code to open files and insert text, library authors would describe what needs to change in a structured way. For example:

Setup: “Create a new module named X with template Y” or “Ensure config setting my_lib.enabled is set to true” or “Add MyLib.Supervisor to the application supervision tree.”

Update: “Replace all calls of old_function with new_function” or “Add new field to config struct if missing” or “Remove deprecated API usage.”

Teardown: “Remove config entries under my_lib” or “Delete generated files X, Y.”

This could be represented in a data format or via a fluent API. Igniter’s builder pattern is a good model: it chains operations on a context to build up changes
hexdocs.pm
hexdocs.pm
. We could provide a standard library module (say Topos.Project) with functions like create_file(path, contents), insert_code(file, at: location, code: snippet), update_config(file, key_path, new_value, update_fn), etc. Authors then implement their on_install or on_update by calling these functions, which accumulate changes. The final result could be a patch set that the tool or compiler applies to the user’s project.

Version Awareness: The mechanism should make it easy to write version-specific changes. For example, a library might include multiple on_update functions each annotated with the source/target version they handle. The tool can pick the correct one(s) to run based on the upgrade path. This encourages library maintainers to think about upgrade paths and possibly supply automated fixes for breaking changes. In the Elixir Igniter context, “upgrade patchers” are defined in the target package and run automatically during mix igniter.upgrade
github.com
. We’d have a similar concept – perhaps with a naming convention or configuration that ties a patch script to a version range (e.g. a script to go from v1.* to v2.0). The package manager can then sequence these as needed.

User Control and Transparency: Even if automated, these code changes should be transparent to the developer. A good practice (followed by Igniter) is to show a diff of what will change and possibly prompt confirmation
hexdocs.pm
. In Topos’s case, if integration happens at compile time, the compiler could output a summary of changes or require a flag acknowledging them. If via a tool, the tool can present a git-like diff. This ensures the developer remains in control and can review what the library is doing to their codebase.

Safety and Idempotence: Hooks should be written in an idempotent way – running them twice shouldn’t double-add the same snippet. For example, if a config entry already exists, the hook shouldn’t duplicate it. Igniter’s patch functions often take care of this (for instance, adding a list element only if not already present, using helper functions like prepend_new_to_list
hexdocs.pm
). We can incorporate similar utilities to make writing safe patches easier. Additionally, any failure in applying patches should fail gracefully, perhaps leaving the project unmodified or rolling back partially applied changes. Since Topos values immutability and robustness, our implementation could treat the code modifications like a transaction – either fully apply all or none.

Interaction with Category-Theoretic Design: Although code generation is a meta-programming concern, we can still align it with our design ethos. The declarative, compositional style of specifying patches is akin to composing pure functions that transform a data structure (in this case, the program’s AST). We can conceptualize the entire project’s source code as an object and each library’s installation patch as a morphism transforming one project state to another. By keeping these transformations modular (each library encapsulates its own) and composable (multiple library installs can combine their changes), we adhere to a principle of composability. Also, because these transformations run outside the normal runtime, they do not introduce side effects into the running program’s logic – they’re performed at build/installation time, preserving the purity of program execution. This separation of concerns (functional core vs. meta-programming layer) is important in category-theoretic language design, where one might distinguish between the internal language (the pure logic) and meta-level operations.

Possible Implementation Paths
1. Compiler/Build System Hooks

One route is implementing this within Topos’s compiler or build system. For example, when the compiler detects a new dependency, it could look for a special module in that dependency (e.g. MyLib.Integrator) and execute a defined install() function from it. Similarly, before upgrading a dependency, the build tool could invoke upgrade(old_version) and pass the old version. These functions, written by library authors using the provided AST-manipulation API, would produce the changes. The compiler could apply the changes to the source files before the next compile phase. This is somewhat analogous to a compiler plugin or macro, except it operates on multiple files/project structure rather than just within one module. Because Topos already has an AST parser available at build time, we have the foundation to parse and manipulate code. We would need to integrate a pretty-printer or patch applier to write changes back to files, similar to how Sourceror turns AST back to source
hexdocs.pm
.

One challenge is ensuring that running arbitrary code at compile time (even if it’s provided by a dependency) is safe. We might sandbox these hook executions or restrict them to only use the provided API (not perform I/O or malicious actions). Since these are essentially build scripts, perhaps running them in a restricted environment is acceptable. This approach also raises questions: Do we recompile the project immediately after an install patch (since new files were added)? How do we handle errors in the middle of patching? These details would need careful design.

Another consideration is ordering: if a user adds multiple libraries at once or in sequence, the compiler/tool might need to determine in what order to apply patches, especially if they touch the same files. Igniter’s approach to composition and flag disambiguation
hexdocs.pm
hexdocs.pm
 shows that when combining multiple generator tasks, conflicts can occur. In our design, we might sidestep some conflicts by not running multiple library installs in a single invocation; but even sequential installs could conflict (e.g., two libraries both want to modify the same function). To mitigate this, our patch DSL should aim for isolated changes (like adding entries to lists, adding new modules) rather than wholesale rewrites. And when conflicts do arise, perhaps the tool can alert the user to manually reconcile, or adopt a last-writer-wins strategy with warning.

2. External Codegen Tool or Package Manager Integration

The simpler path to start with is an external tool integrated with Topos’s package manager. For instance, Topos could have a command-line tool (let’s call it topos pkg) with subcommands:

topos pkg install <lib> – which not only fetches the library (similar to mix deps.get) but then reads the library’s integration manifest and applies any on_install patches to the project.

topos pkg update <lib> – which upgrades the dependency version and triggers any on_update patches provided by the new version.

topos pkg remove <lib> – which removes the dependency and optionally runs a on_remove cleanup to undo configurations.

This approach leverages the package management workflow. It keeps the code modification step explicit (the developer knows it’s happening when running these commands). It also separates concerns: the compiler proper just compiles code that’s already laid out, while the package tool handles modifying code when libraries are added or changed.

Implementing this as a tool might actually use the same AST-manipulation libraries – possibly we could provide an official Topos AST library analogous to Sourceror, so that the codegen tool and library authors share a common way to parse and print code. The advantage is we can evolve this tool without changing the compiler, and users can opt into it. For example, some conservative developers might choose not to auto-run patches and instead do things manually; having it in tooling allows that flexibility (the tool could print suggestions if not auto-applied).

The external tool could also be language-agnostic to an extent – it might operate on the text of the code using the AST, but not need to hook into the compiler’s internals. This is how Igniter functions for Elixir – it’s a Mix task that uses Elixir’s AST capabilities but isn’t part of the compilation pipeline itself.

3. Hybrid Approach

We could eventually aim for a hybrid: start with the external tool and, if it proves extremely beneficial, integrate deeper into developer workflow. For instance, the package manager could by default run on_install hooks after dependency resolution, unless a flag is set to disable it. Or the IDE/Editor integration for Topos could detect a library’s hints and suggest applying them. Over time, if the concept is widely adopted, we might formalize it in the language spec or build process.

Benefits of Integrating Igniter’s Concept

Integrating an Igniter-inspired system into Topos offers several tangible benefits:

Streamlined Library Setup: Developers can add a library and have necessary boilerplate or configuration inserted automatically, saving time and reducing setup errors. This is akin to how Igniter’s mix igniter.install can “automatically add dependencies to your project” and run the library’s installer script
github.com
github.com
. In Topos, this could mean less manual tweaking of project files when adopting new libraries.

Safer Upgrades: As libraries evolve, API changes often require changes in user code. By providing a mechanism for libraries to supply upgrade patches, Topos can automate much of the upgrade process. This reduces the burden on developers to read changelogs and manually fix breaking changes. Igniter’s upgraders “apply codemods at the same time” as dependency updates
github.com
github.com
 – similarly, Topos could make version bumps less risky by applying library-provided transformations. Ultimately this encourages a healthier ecosystem where updates are easier to adopt (fewer stale projects stuck on old versions due to upgrade friction).

Consistency and Reduction of Human Error: When code modifications are encoded in a script, they are repeatable. A new team member or a continuous integration environment can run the same install script to set up a project, getting the same result. This avoids the “it works on my machine” issues due to someone forgetting to perform a manual step. It also means that if a library’s setup instructions change, the tool can update the code uniformly across projects. In other words, it’s infrastructure as code, but for project setup. The configuration stays consistent, avoiding the “stale configuration files” problem
elixirmerge.com
 because the tool can update config files systematically rather than relying on humans.

Encouraging Good Library Practices: Knowing that this system is available may encourage library authors to design clear integration points and think about backwards compatibility. It provides a channel to assist users beyond just documentation: actual executable guidance. For example, instead of just noting “If upgrading to 2.0, rename all uses of foo() to bar()”, the author can provide a patch that does it. This can elevate the overall quality of the ecosystem.

Category Theory Alignment: At a philosophical level, having deterministic transformations from one version of code to another resonates with the mathematical approach of the language. Each library’s integration can be seen as a morphism that adds that library’s structures into the project, and removing the library is like an inverse (if possible) morphism. This is not a typical lens for code generators, but it underscores that these operations should be well-defined, composable, and ideally reversible or at least predictable – qualities valued in category theory and functional programming.

Potential Challenges and Considerations

While the benefits are attractive, integrating an Igniter-like feature raises some challenges we must consider:

Complexity vs. Benefit: There is a risk of over-complicating the language or its tooling. Many languages get by fine without automated project patching. We must ensure that the added complexity is justified by real productivity gains. If most libraries don’t need such hooks, a whole system for it might be over-engineering. We should survey our intended use-cases: do we anticipate frameworks or libraries in Topos that, similar to Phoenix or Ash in Elixir, would greatly benefit from scaffolding dozens of files or config entries? If Topos is meant to enable such high-level frameworks, then having this integration feature could be a big selling point. Otherwise, a simpler macro system might suffice for most codegen needs.

Learning Curve: Developers using Topos will need to understand that adding a dependency can also mutate their codebase. This is not common in many languages, so documentation and tooling support (like showing diffs, as mentioned) is key. We’d want to avoid confusion where a dev wonders “how did this code get here?” Making the process explicit and logged helps mitigate this.

Tooling Ecosystem (Editors, VCS): Auto-generated code can sometimes conflict with developer edits. For example, if a user has manually customized a section of code that an upgrade patch tries to change, what happens? Ideally, the patch should detect the divergence and either merge intelligently or warn the user. This is similar to git merging. We might need a strategy for patch failures or conflicts (perhaps leaving TODO comments in code if something couldn’t be auto-fixed). Additionally, integration with version control is important – developers will typically commit the changes that the generator made. We should encourage commit messages or a log of changes for clarity. Perhaps the topos pkg tool can output a summary that can be used in commit description.

No Direct Igniter Dependency: As per the guidelines, we are not going to use Igniter itself but be inspired by it. This means we wouldn’t, for example, include Igniter or Sourceror as libraries in Topos’s implementation (which likely wouldn’t be feasible anyway since they’re Elixir code). Instead, we’ll implement analogous functionality in Topos’s own compiler/toolchain. Fortunately, the concepts are language-agnostic: parsing source to AST, applying transformations, and printing back to source. We can use existing Topos parser modules and write our own printer or patch generator. The data structures will differ (since Topos’s AST is its own), but the core idea remains: source -> AST -> transform -> source
elixirforum.com
.

Performance: Running codegen patches will add overhead to the install/update process. Usually this is fine since installing or updating a dependency is not extremely frequent and can be done offline. However, we should ensure that the AST parsing and printing for even a moderately large project is efficient. Perhaps only the files that need change will be parsed, rather than the entire codebase. Techniques like doing a targeted AST search or using a simplified representation for certain config changes might help. We might take inspiration from Sourceror’s “patch” approach that only rewrites small text ranges
hexdocs.pm
 to minimize impact on large files.

Scope of Changes: We might decide to limit what library hooks can do for sanity. For example, maybe hooks are only allowed to add new files under a certain directory (like a “generated” or “integrations” folder) and append to certain well-known config files, rather than arbitrary changes anywhere. This could prevent a rogue or buggy script from wreaking havoc. Igniter, being a general tool, doesn’t impose such limits (it can theoretically alter anything in the project). But as a built-in feature, we could enforce conventions – e.g., libraries should not delete user code, only add or warn about deprecated usage. Teardown might not auto-delete files that have been edited by the user, etc. Setting these guidelines will protect against unexpected data loss or confusion.

Conclusion

In summary, the Igniter library in Elixir introduces a powerful paradigm of treating code as data – allowing projects to modify themselves (with guidance from library-provided scripts) to ease integration and maintenance. We see a clear opportunity to adopt this concept in Topos. By providing a declarative, composable mechanism for library setup and updates – either built into the language’s compilation process or as an official tool – we can significantly improve the developer experience. Libraries in Topos could come with first-class support for “plug-and-play” installation, version upgrades with minimal fuss, and clean removal, all managed via AST-based transformations for reliability.

However, we must balance this with complexity and safety. The current Topos design has no such feature (beyond basic AST parsing during compilation), so this would be a new frontier. It likely makes sense to prototype it as part of the Topos toolchain (e.g., package manager) first. If it proves its worth, it can be more deeply integrated over time. The vision is that adding a library in Topos would not be a tedious chore of copying config and boilerplate, but a seamless operation where the language (or its tools) “knows” how to wire things up according to the library author’s intentions.

In doing so, we preserve the spirit of category theory by focusing on compositional transformations (each library’s integration can be composed with others) and clarity (making side-effects like code modifications explicit and declarative). Igniter’s success in Elixir shows that this approach can reduce errors and improve consistency
elixirmerge.com
. Bringing a similar capability to Topos, we would aim for an even tighter integration – making it a natural part of the development workflow, and thereby distinguishing Topos as a language that truly understands and assists with the structure of programs, not just at runtime but throughout their evolution.

Sources:

Igniter README – Ash Framework: Definition and features of Igniter
github.com
github.com
.

Igniter HexDocs – Writing Generators: Example of creating a file and updating config via Igniter’s API
hexdocs.pm
hexdocs.pm
.

ElixirForum discussion on Igniter: Confirms the pattern “source → AST → manipulate → source” for code modifications
elixirforum.com
.

Introducing Igniter (ElixirMerge blog): Rationale for AST-based code generation and project patching to avoid stale configs and manual updates
elixirmerge.com
elixirmerge.com
.

Sourceror documentation: Explanation of using AST manipulation to implement codemods (with example)
hexdocs.pm
hexdocs.pm
.
