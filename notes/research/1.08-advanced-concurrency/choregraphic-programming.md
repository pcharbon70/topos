**Choreographic Programming and the BEAM Ecosystem**

_Choreographic programming_ is a paradigm for building distributed systems where you write a single _global program_ that describes how multiple components (or _roles_) interact, and then automatically derive the code for each component from that global description[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=distributed%20software,by%20a%20compiler%20into%20executable)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=Abstract%20In%20the%20paradigm%20of,development%20and%20avoids%20communication%20mismatches). In simpler terms, instead of coding the logic of each node or service separately and hoping they communicate correctly, you define the _"choreography"_ - the overall communication flow - in one place. This choreography is then projected or compiled into local programs for each participant, guaranteeing they all follow the intended sequence of interactions[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=distributed%20system%2C%20choreographic%20programming%20allows,using%20pseudocode%20in%20Figure%201)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Choreographic%20programming%20adds%20a%20layer,to%20ensure%20their%20corresponding%20actors). The result is that communication mismatches (like one service sending a message that no other service expects, or two services waiting on each other forever) are eliminated by construction[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=,development%20and%20avoids%20communication%20mismatches)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=take%20place%2C%20the%20paradigm%20lifts,6). In this answer, we'll explain the core concepts of choreographic programming in a beginner-friendly way, use examples (with Erlang-style pseudocode) to illustrate how it works, and discuss how these ideas relate to the BEAM ecosystem (Erlang/OTP's runtime) - including potential benefits and challenges of applying choreographies in an Erlang/OTP architecture.

**What is Choreographic Programming?**

In traditional distributed programming, a developer writes a separate program for each node or service (each _role_ in the system) and must ensure that all these programs exchange messages in a compatible way. The overall communication pattern often exists only in design documents or in the developer's mind (for example, drawn as a sequence diagram on a whiteboard), but it's not explicitly enforced by code[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=A%20choreography%20makes%20a%20global,as%20code%2C%20and%20is%20deeply). This can lead to components "falling out of sync" - one might send a message that the other isn't expecting, leading to errors or deadlocks[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=systems%2C%20the%20global%20view%20is,end%20testing%20holds%20them%20together).

**Choreographic programming** flips this approach: you program the _global interaction_ directly. As one research thesis defines it, choreographies give "a global view of how messages are exchanged by endpoint nodes, instead of separately defining the behaviour of each endpoint"[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=Choreographies%20are%20descriptions%20of%20distributed,formal%20investigations%20of%20choreographies%20show). In other words, you describe _in one place_ the sequence of messages and computations that occur among all the participants. From that single choreographic description, a compiler or code generator can produce the code that each participant (endpoint) needs to run[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=distributed%20system%2C%20choreographic%20programming%20allows,using%20pseudocode%20in%20Figure%201). Each participant's local program will handle its part of the protocol - sending or receiving exactly the messages it's supposed to - such that together they implement the global choreography.

A key feature of choreographic programming languages is a special syntax for communications. For example, the choreographic language _Chorex_ (an Elixir-based choreography DSL) uses a _delivery notation_ ~> to denote message passing[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=The%20key%20aspect%20of%20a,Bob.v). A snippet like Alice.x ~> Bob.y in a choreography means: _"Alice evaluates expression x and sends the result to Bob, who stores it in variable y."_ This single choreographic statement would be realized under the hood by Alice performing a send operation and Bob performing a receive operation. In Erlang-like pseudocode, it corresponds to something like:

%% On Alice's side:

BobPid ! ResultOfExpr, % send the value of x to Bob

%% On Bob's side:

receive Value -> Y = Value end % receive the value into variable y

The choreographic notation captures both sides of that interaction in one concise line of code[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=The%20key%20aspect%20of%20a,Bob.v). By writing interactions this way, you cannot accidentally write Bob's code to expect a different message than what Alice sends - the choreography ties the send and receive together by design. In fact, entire classes of communication errors become _unrepresentable_ when using choreographies: every send has a matching receive by construction, so you avoid misaligned message formats or one-sided waits[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=at%20Bob%3A%20Bob%20can%20use,are%20paired%20by%20design%20through). This also means issues like **deadlocks** (where two components wait on each other forever) are prevented or caught early, because a well-formed choreography will not compile if the communication pattern could deadlock[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=take%20place%2C%20the%20paradigm%20lifts,6). Researchers have shown that choreographic programs, when compiled to their endpoints, are _deadlock-free_ and free of race conditions by construction[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=software,when%20dealing%20with%20such%20nontrivial)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=with%20strong%20safety%20and%20liveness,6).

To sum up, choreographic programming provides:

- **A single source of truth for interactions:** The entire protocol is specified in one global program, improving clarity over scattered message-handling code.
- **Automatic distribution of code:** A compiler _projects_ the global choreography into code for each participant, so developers don't have to write the low-level send/receive logic for each node[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=Abstract%20In%20the%20paradigm%20of,development%20and%20avoids%20communication%20mismatches)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Choreographic%20programming%20adds%20a%20layer,to%20ensure%20their%20corresponding%20actors).
- **Built-in consistency and safety:** Since one global program defines all sides of every communication, you avoid mismatched assumptions. If the choreography is valid, participants can't get out of sync or accidentally deadlock on a missing message[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=take%20place%2C%20the%20paradigm%20lifts,6).

**Choreography vs. Traditional Approaches**

It's helpful to contrast choreographic programming with more traditional approaches to coordinating distributed systems. Two common ways to design interactions are often described as **orchestration** and **choreography** in the context of microservices or workflows:

- **Orchestration:** One central coordinator (or orchestrator service) calls or instructs each participant in turn, determining the global flow. This is like a conductor in an orchestra, explicitly directing each musician when to play.
- **Choreography (conceptual):** Each participant follows an agreed protocol, reacting to messages or events, without a single central controller. This is like a dance choreography - everyone knows the steps to perform and with whom to interact at each moment, but there's no single dancer telling others what to do.

Choreographic programming aligns with the second approach - it formalizes the idea of a _global dance plan_ for all the distributed components. However, it goes a step further by providing a programming model to write that plan as code. Unlike a purely informal choreography where each team writes their service code according to a document, choreographic programming ensures the plan is explicitly implemented. One author describes that in traditional development, the "global view is merely a design document or a sketch on a whiteboard," whereas in choreographic programming _the global view becomes actual code_ that is "deeply connected to the actual behavior of actors"[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=A%20choreography%20makes%20a%20global,as%20code%2C%20and%20is%20deeply). This means the burden on the programmer shifts from writing a lot of coordinated boilerplate in each service to writing one coherent description of their interactions. The compiler then takes care of generating the necessary send and receive operations in each service's code[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=distributed%20system%2C%20choreographic%20programming%20allows,using%20pseudocode%20in%20Figure%201)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=,development%20and%20avoids%20communication%20mismatches).

To illustrate the difference, imagine a simple scenario in a distributed system using a traditional approach versus a choreographic approach:

- _Traditional approach:_ Suppose we have three services (or Erlang processes) A, B, and C. The developer must implement logic in A to send the correct messages to B and C, code in B to receive A's message and maybe forward something to C, and code in C to receive from the others. Each piece is written separately, and it's up to the developer to ensure these independent pieces line up to form the proper sequence. For example, A's developer might write B_pid ! {data, X} and C_pid ! {info, Y}; B's developer writes a receive {data, X} -> ... end; etc. If any detail (like the message format or order) is inconsistent, the system may malfunction. Only integration testing or careful reasoning will catch mismatches.
- _Choreographic approach:_ The developer writes a **global** sequence of interactions: e.g., "A sends data X to B, then A sends info Y to C, then B sends result Z to C." This sequence is written once, in one place. From it, the choreographic framework generates the code for A, B, and C. A's code will contain the sends to B and C; B's code will contain a receive from A and then a send to C; C's code will have receives from A and B, and so on - all consistent by construction. The global choreography itself acts as an executable specification of the protocol.

**A Simple Choreography Example**

Let's walk through a concrete (but simple) example to make this more tangible. Consider a scenario with three participants - we'll call them **Alice**, **Bob**, and **Carol** - collaborating in a small workflow. Say Alice is placing an order with Bob, and Bob needs to get a shipping quote from Carol, then return the quote to Alice. We can describe this interaction with a choreography like so:

sequenceDiagram

participant Alice

participant Bob

participant Carol

Alice->>Bob: Order

Bob->>Carol: ShippingRequest

Carol-->>Bob: ShippingQuote

Bob-->>Alice: QuoteResponse

In this **sequence diagram**, which represents a choreography, we have a global view of the message flow:

- **Alice -> Bob: Order** - Alice sends an order request to Bob.
- **Bob -> Carol: ShippingRequest** - Bob, upon receiving the order, sends details to Carol to get a shipping quote.
- **Carol -> Bob: ShippingQuote** - Carol replies to Bob with the quote.
- **Bob -> Alice: QuoteResponse** - Bob forwards the shipping quote (or a combined response) back to Alice.

This single diagram (or corresponding choreographic code) captures the _whole story_ of the interaction. Now, if we were to _project_ this choreography into actual code for each role, it would look something like the following in Erlang-style pseudocode:

- **Alice's process** would do two things: send the order to Bob, then wait for Bob's response:
- %% Alice's behavior (pseudo-code)
- Bob_Pid ! {order, OrderDetails}, % Step 1: send order to Bob
- receive
- {quote, QuoteDetails} ->
- % Step 4: receive the quote response from Bob (then process it)
- end.
- **Bob's process** would receive the order from Alice, then contact Carol, then finally reply to Alice:
- %% Bob's behavior (pseudo-code)
- receive
- {order, OrderDetails} ->
- Carol_Pid ! {request, OrderDetails}, % Step 2: send shipping request to Carol
- receive
- {quote, QuoteInfo} ->
- Alice_Pid ! {quote, QuoteInfo} % Step 4: forward Carol's quote back to Alice
- end
- end.
- **Carol's process** waits for a shipping request and replies with a quote:
- %% Carol's behavior (pseudo-code)
- receive
- {request, Details} ->
- %% Step 3: process the request and prepare a quote
- QuoteInfo = make_quote(Details),
- Bob_Pid ! {quote, QuoteInfo} % send quote back to Bob
- end.

Each of these behaviors is exactly what one would hand-write in Erlang for such a protocol - but in choreographic programming, you derive them systematically from the global specification. The choreographic program (the global sequence of interactions) ensures that **for every send in one role, there is a corresponding receive in another**. For instance, the step "Carol -> Bob: ShippingQuote" in the choreography guarantees that Bob's code will have a receive {quote, ...} and Carol's code a matching send. It would be impossible (or a compile-time error) to have Carol send a message that Bob isn't prepared to receive, or vice versa[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=with%20strong%20safety%20and%20liveness,6). Essentially, the global description acts as a contract that all generated endpoint programs fulfill. This greatly simplifies reasoning about the system: you can **look at one choreography to understand the conversation among components**, rather than tracing through multiple modules and message handlers scattered across the codebase.

**Note:** The choreography itself doesn't mean there is a single centralized runtime controller. In our example, there isn't a "master" process instructing Alice, Bob, and Carol. Instead, the global program is a _design-time artifact_ - it gets compiled into decentralized code. At runtime, Alice, Bob, and Carol execute their respective pieces concurrently and interact via message passing, just as they would in a manually coded distributed system. The difference is how the code was obtained and the guarantees we have about its coordination correctness.

**Choreographic Programming in the BEAM/OTP Environment**

Now let's discuss how these concepts relate to the **BEAM ecosystem** - the Erlang/OTP platform and its concurrency model. Interestingly, the BEAM (which underlies Erlang and Elixir) is _naturally suited_ for choreographic programming, because it already embodies the core ingredients: isolated processes that communicate via asynchronous messages. In Erlang/OTP, concurrent activities are modeled as lightweight processes (actors) that do **not share memory** and synchronize solely by sending/receiving messages[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=The%20BEAM%27s%20concurrency%20model%2C%20grounded,maintainable%20systems%20much%20more%20effortless)[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=BEAM%20handles%20concurrency%20through%20lightweight,fault%20tolerance%20and%20system%20reliability). This model maps closely to the assumptions of choreographic programming (which is often formalized on message-passing process calculi).

Erlang processes are extremely lightweight and the BEAM can run **thousands or even millions of them concurrently** on one machine[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=BEAM%20handles%20concurrency%20through%20lightweight,fault%20tolerance%20and%20system%20reliability). They can also be distributed across multiple nodes: an Erlang/OTP system can have nodes (on different machines) connected in a cluster, where sending a message to a process on a remote node is as transparent as sending to a local process (aside from network latency). This means a choreographic program's "roles" could be implemented as processes on potentially different nodes, and the message passing described by the choreography can be realized using Erlang's native Pid ! Message primitives, even across the network. In practice, the BEAM's location-transparent messaging fits well with choreographies - the global communication steps remain the same whether participants are on the same node or different nodes, as long as you have their process identifiers or registered names.

Another strength of the BEAM is its **fault-tolerance and supervision** mechanisms. Erlang/OTP has the concept of supervisors and "let it crash" philosophy, where if a process fails, a supervisor process can start a new one to replace it, potentially restoring state or taking corrective action. Choreographic programming can leverage this as well. One challenge in distributed protocols is handling failures or dynamic changes (e.g., a participant goes down or a new one takes over). A choreography needs to account for the possibility that an expected message might not arrive because the sender crashed or the network broke. While basic choreographic models often assume ideal conditions, in the real world these issues must be addressed. The BEAM provides tools to detect and handle such failures (for example, processes can monitor each other, and supervisors can restart crashed processes).

In fact, recent research has _combined choreographic programming with OTP-style fault tolerance_. **Chorex** - a choreographic programming library for Elixir (which runs on BEAM) - is an example. Chorex integrates choreographies into the Elixir language via macros, and crucially, it _tolerates process failures by using OTP's supervision capabilities_[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Abstract%20We%20built%20Chorex%2C%20a,doing%20so%20achieves%20tight%20integration)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=fallacy%20,blocks%20into%20code%20to%20make). In Chorex, if one actor (process) in the choreography crashes, the system will spawn a new process to replace it, restore its state from a checkpoint, and update the other participants with the new process's address[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=an%20un,At%20runtime%2C%20a%20supervisor). This is done by combining the choreography compiler with runtime monitoring: the choreographic program can include _checkpoint/rescue_ blocks (similar to try/except) for recovery logic[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=achieves%20this%20goal%20through%20a,At%20runtime%2C%20a%20supervisor). The compiler generates code such that each participant periodically checkpoints its state, and a supervising process (an OTP supervisor) oversees the group. If a process dies, the supervisor restarts it and uses an out-of-band message to inform the other participants of the newcomer's identity (so they can continue the protocol with the new process)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=an%20un,At%20runtime%2C%20a%20supervisor). This solution addresses one of the classic "fallacies of distributed computing" - the assumption that the network topology doesn't change (i.e., nodes don't fail)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=practical%20choreographic%20programming,8%29%20the). Thanks to the BEAM's support for fault tolerance, choreographic programs can be made more robust by design.

Beyond fault tolerance, the general **Erlang/OTP design principles** mesh well with choreographic thinking. Erlang applications are often structured as **multiple worker processes and manager processes** that interact following certain patterns (for example, a GenServer calling another GenServer, or a pipeline of processes each sending results to the next). Typically, developers use OTP behaviors and define handle_call/cast functions, explicitly coding what messages each process will handle. With choreographic programming, one could imagine writing a higher-level specification of these message exchanges and letting a tool generate the boilerplate. This could reduce errors in complex OTP systems where many processes exchange messages in non-trivial sequences. Indeed, the choice of Elixir for Chorex was partly because Elixir (and Erlang) _already provide the primitives for low-latency, distributed, fault-tolerant messaging_, making it an ideal host for a choreography language[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Chorex%20is%20a%20domain,primitives%20have%20enabled%20fast%2020%3A4).

To give a flavor of how one might apply choreographic programming on BEAM, consider using a choreography to coordinate multiple OTP nodes or processes. You might define roles corresponding to different services or nodes (e.g., :frontend, :worker, :database roles). The choreography could then describe, say, "frontend sends request to worker, worker queries database, database replies to worker, worker sends response to frontend" - all in one coherent block of code. A projection tool would generate, for each role, an Erlang/Elixir module (or a set of functions) that implement that role's part of the protocol. These modules could be integrated into an OTP application - for instance, each role module could run as a GenServer or a spawned process under a supervisor. The important point is that the message-passing structure between them is guaranteed to follow the choreography. This could significantly simplify reasoning about the correctness of inter-process communication in an OTP system. Instead of reasoning about each handle_info and receive scattered across modules, you reason about the single choreography, which the framework ensures is correctly realized in the code.

It's worth noting that choreographic programming is an active area of research, and various languages and libraries are emerging to bring these ideas into practical use. Besides Chorex for Elixir, there are projects like **Choral** (which brings choreographies into Java) and **Microservices Projection** frameworks for Haskell, Rust, TypeScript, and more[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Languages%20that%20support%20choreographic%20programming,Haskell%2C%20introduces%20a%20dynamic%20approach). The fact that a language-integrated approach exists for the BEAM (Elixir) is a strong sign that choreographic programming can be adapted to the actor-model world of Erlang/OTP. BEAM's combination of concurrency, distribution transparency, and supervision makes it fertile ground for such high-level coordination models.

**Benefits of Choreographic Programming (and Its Potential on BEAM)**

Choreographic programming offers several **benefits** that are attractive, especially in the context of building reliable distributed systems on BEAM:

- **Correctness by construction:** Perhaps the biggest benefit is that many communication errors are prevented. Since a single program describes all interactions, you won't have one process sending a message that no one is ready to receive, or two processes both waiting for a message from each other (deadlock). These problems are handled at the choreography level. As research by Montesi et al. notes, choreographies inherently avoid issues like deadlocks and race conditions, and the endpoint code generated from a choreography is _safe by construction_ with respect to those communication issues[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=software,when%20dealing%20with%20such%20nontrivial). In practice, this means less debugging of tricky concurrency bugs such as "why did service A never get a response?" - such situations are designed out from the start[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=with%20strong%20safety%20and%20liveness,6).
- **Global clarity:** The entire protocol is visible as a single unit. This is great for understanding and documenting system behavior. For a senior engineer (or any engineer) looking at an Erlang/Elixir codebase, it can be hard to piece together the intended message flow by jumping through multiple modules. A choreography makes the intended message flow explicit. This can serve almost like an executable documentation of the system's communication pattern[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=A%20choreography%20makes%20a%20global,as%20code%2C%20and%20is%20deeply). If the protocol needs to change, you have one place to modify, rather than N different services to carefully update in tandem.
- **Less boilerplate for coordination:** Writing distributed code often involves a lot of repetitive send/receive handling, serialization of messages, timeouts, etc., in each service. A choreographic approach can automate those parts. The programmer writes in a more declarative style ("Alice sends X to Bob, then Bob sends Y to Carol..."), and the compiler emits the necessary lower-level code. This can speed up development and reduce human error. As one paper describes, the paradigm _"relieves the programmer from manually writing the separate send and receive actions"_ for each participant[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=,development%20and%20avoids%20communication%20mismatches). This is especially beneficial on BEAM, where you might otherwise write many handle_call or receive clauses; the choreographic library can generate those for you.
- **Safety guarantees checked early:** Many choreographic systems come with a type system or formal checks (often related to _session types_) that verify the choreography is coherent. This means you can catch mistakes at compile-time rather than at runtime. For instance, if you somehow wrote a choreography where Alice tries to send a message of one type but Bob expects another type, the compiler would flag a type mismatch. Or if your global logic had a potential deadlock (like two roles waiting on each other's message in a cycle), the choreography language might reject it or warn you[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=With%20choreographies%2C%20classes%20of%20communication,used%20before%20it%20is%20bound). Bringing these checks into the development phase reduces the reliance on integration testing to find protocol bugs.
- **Alignment with BEAM's strengths:** On the BEAM, where processes and message passing are cheap, choreographic programs can exploit massive concurrency. You could scale up a choreographic interaction to many participants without a single coordinator bottleneck. Also, BEAM's fault isolation means if one participant in the choreography crashes, it won't take down the others - and with supervision (as discussed with Chorex), you can even recover transparently. This synergy means choreographic programming can be used to build _fault-tolerant protocols_. For example, if you have a multi-step transaction among several Erlang nodes, a choreography could ensure that if one node crashes mid-protocol, the system can restart that role and still complete or roll back the interaction consistently[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=fallacy%20,blocks%20into%20code%20to%20make)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=an%20un,At%20runtime%2C%20a%20supervisor). Such resilience is a hallmark of OTP systems, and choreographies can be designed to work hand-in-hand with those mechanisms.
- **Maintainability and evolution:** When the inter-service contract needs to evolve (a new message is added, or the order of steps changes), having a choreographed approach can simplify updates. You modify the choreography and re-project the endpoints. This reduces the chance of one service being updated without updating others accordingly. In an Erlang context, this could reduce version skew issues where one node expects a different message format than another after a change. The choreography acts as a single version of truth that you update, ensuring all parts change in lockstep.

**Challenges and Considerations**

While choreographic programming is powerful, it's not a silver bullet. There are several **challenges and considerations** to be aware of, especially when thinking about applying it in a BEAM-based architecture:

- **Learning curve and tooling:** Choreographic programming introduces a new way of thinking and possibly new language syntax/DSL to learn. A senior engineer new to distributed systems might need to first grasp the global-program concept and trust the code generation for each participant. The ecosystem is still maturing - there are research prototypes (like Chorex for Elixir, Choral for Java, etc.), but not yet widely adopted industrial tools. Using these may require adopting a research-grade library or language, which could have limitations or less community support. In the Erlang world, where many rely on battle-tested OTP design principles, introducing a choreography DSL might face resistance or compatibility issues with existing code. However, efforts like Chorex demonstrate that it's feasible to integrate choreographies into an existing language via libraries[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Languages%20that%20support%20choreographic%20programming,to%20enable%20an%20Internet%20Relay)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Chorex%20is%20a%20domain,First%2C%20it%20compiles%20to%20the).
- **Interoperability with non-choreographed components:** In a real system, you might not control all participants or you might want to integrate with legacy services that weren't generated from the choreography. Early choreographic approaches often assumed you would generate _all_ the endpoint code from scratch, which can be "intrusive" when some components already exist[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=features%20explored%20in%20theoretical%20models,we%20carry%20out%20the%20first). If, say, an Erlang node needs to talk to a third-party service (that doesn't use your choreography framework), you have to ensure the choreographic program can interface with that. This might require writing adapters or allowing the choreography to include I/O actions that interact with external code. Recent developments have started to address this by allowing choreographies to interoperate with manually written code[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=none%20of%20these%20languages%20have,party%20implementations%20of%20some)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=asynchronous%20nature%2C%20while%20user,for%20which%20we%20extend%20the), but it remains a practical consideration.
- **Handling real-world issues (the "fallacies of distributed computing"):** Choreographic programming, by itself, doesn't _magically solve_ the inherent problems of distributed systems. Things like network unreliability, variable latency, partial failures, and network partitions still need to be dealt with. As noted in one paper, current choreographic languages don't address all of the classic eight fallacies of distributed computing[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=practical%20choreographic%20programming,8%29%20the) - for example, they might assume that if one process sends a message, it will eventually be received, which isn't always true in a real network. On the BEAM, you would still have to consider using monitors (Process.monitor) to detect if a remote process died, set timeouts on receive blocks, handle duplicate or out-of-order messages, etc., as appropriate. Choreographies can be extended with such mechanisms (e.g., timeout branches or alternate flows for failures), but that adds complexity to the global program. The challenge is to balance the abstraction (global simple view) with the gritty details of real networks. BEAM gives you some tools (like monitors and links for failure detection, or ordering guarantees on messages between two given processes), but not all problems are eliminated.
- **Asynchrony and ordering:** Distributed choreographies often need to allow asynchronous messaging (messages in flight concurrently). Many choreographic programming models guarantee deadlock-freedom partly by enforcing a certain structured ordering of communications. Introducing asynchrony (e.g., letting messages cross in flight, or allowing parallel interactions) complicates the theory. The BEAM model is fully asynchronous - messages don't necessarily get delivered in the global order you might visualize, especially if independent branches of a choreography occur in parallel. More advanced choreographic languages have been evolving to handle _full-duplex asynchrony_ (where parties can send messages simultaneously without blocking)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=performed%20by%20participants%2C%20which%20simplifies,the%20relevance%20of%20the%20different)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=,detecting%20that%20choices%20on%20alternative), but ensuring the global program still makes sense requires care. For a practitioner, this means that if you have a choreography with parallel or concurrent interactions, you must understand how it maps to the interleavings on BEAM processes. The tools might insert synchronization to avoid races, which could affect performance or complexity.
- **Dynamic topology changes:** Choreographies typically describe a fixed set of roles (e.g., Alice, Bob, Carol) and a fixed communication pattern. But what if your system is more dynamic - e.g., new nodes can join a cluster, or a pool of workers where the number isn't fixed? Adapting choreographic programming to such scenarios is an ongoing area of research. You might need constructs for spawning new roles or handling a variable number of participants. In Erlang, it's common to dynamically spawn new processes or have supervision trees that scale workers up and down. Incorporating that with a choreography could be challenging. Some approaches involve parameterized choreographies or treating new participants as iterations of a role, but this is complex to get right. In practice, you may end up using choreographic programming for the _fixed protocol aspects_ of your system (for instance, a fixed set of services that always interact in a certain pattern), and use traditional dynamic techniques for the more fluid parts (like a dynamic worker pool that a choreographed coordinator process sends tasks to).
- **Performance and overhead:** Generating code through a choreography compiler might not always yield the most optimized code compared to hand-written, specialized code. There could be some overhead or indirection added by the framework (though ideally the compiler is pretty direct). For BEAM specifically, one must consider how the choreography runtime handles things like message routing and process registration. If the choreographic system tracks participants (for example, naming processes or forwarding addresses on failure), there could be a slight cost. However, since BEAM is very efficient at message passing and process management, this overhead might be negligible for most use cases. It's still something to consider - in performance-critical paths, one might inspect the generated code to ensure it's not doing anything unnecessary. The good news is that choreographic code generation can take advantage of BEAM's efficient primitives directly (Chorex, for example, ultimately produces Elixir/Erlang code using normal sends and receives, just orchestrated by the macro system).
- **Mindset shift:** Finally, a non-technical challenge is the shift in mindset required. Engineers are used to thinking either in terms of _their service's perspective_ (when writing each service in isolation) or in terms of a central orchestrator's perspective (when using an orchestrator approach). Choreographic programming asks you to think from a _neutral, global perspective_. It's almost like writing a play or script for multiple actors at once, rather than writing each actor's lines separately. For those new to distributed systems, this might actually be a boon (they won't have to unlearn some bad habits), but it still requires careful thought to make sure the global logic is correct. Once written, though, many find it easier to reason about the one choreography than to reason about N separate programs. It's a bit of upfront effort in design for a payoff in clarity and reliability.

In conclusion, choreographic programming is a promising approach to building distributed systems that can complement the Erlang/OTP (BEAM) ecosystem nicely. It brings a high-level clarity by letting you code "who talks to whom, and when" in one place, and then automatically handles the gritty details of sending and receiving messages on each node. This approach aligns well with BEAM's actor model - where isolated processes communicate by messages - and can leverage BEAM's strengths in concurrency and fault tolerance[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=The%20BEAM%27s%20concurrency%20model%2C%20grounded,maintainable%20systems%20much%20more%20effortless)[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=BEAM%20handles%20concurrency%20through%20lightweight,fault%20tolerance%20and%20system%20reliability). A senior software engineer new to distributed systems can think of it as writing a single coherent **protocol script** for their cluster of Erlang/OTP processes. The benefits include fewer coordination bugs, easier understanding of complex interactions, and safer concurrency. However, adopting choreographic programming also means embracing new tools or libraries and being mindful of real-world issues like failures and network concerns that still must be addressed through the model or underlying runtime. As the BEAM community explores ideas like Chorex, we may see more practical patterns and frameworks that use choreographies to build robust distributed applications. The end goal is to make distributed systems development less error-prone and more developer-friendly - a goal very much in line with Erlang's original philosophy of building reliable systems that "just work". By integrating choreographic programming concepts, BEAM-based systems could achieve an even higher level of reliability and clarity in how they coordinate their many moving parts, truly dancing in step according to a well-defined choreography.

**Sources:**

- Fabrizio Montesi, _Choreographic Programming (Ph.D. Thesis)_ - IT University of Copenhagen, 2013. (Definition of choreographies and safety properties)[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=Choreographies%20are%20descriptions%20of%20distributed,formal%20investigations%20of%20choreographies%20show)[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=software,when%20dealing%20with%20such%20nontrivial)
- Lovro Lugović and Fabrizio Montesi, _"Real-World Choreographic Programming: Full-Duplex Asynchrony and Interoperability,"_ _The Art, Science, and Engineering of Programming_, vol. 8, no. 2, 2024. (Overview of choreographic programming paradigm and its benefits in practice)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=Abstract%20In%20the%20paradigm%20of,development%20and%20avoids%20communication%20mismatches)[arxiv.org](https://arxiv.org/pdf/2303.03983#:~:text=take%20place%2C%20the%20paradigm%20lifts,6)
- Ashton Wiersdorf and Ben Greenman, _"Chorex: Restartable, Language-Integrated Choreographies,"_ _The Art, Science, and Engineering of Programming_, vol. 10, no. 3, 2025. (Choreographic programming in Elixir/BEAM with fault tolerance)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=The%20key%20aspect%20of%20a,Bob.v)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=an%20un,At%20runtime%2C%20a%20supervisor)
- _Choreographic Programming_ - University of Southern Denmark (Research portal summary of Montesi's work)[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=Choreographies%20are%20descriptions%20of%20distributed,formal%20investigations%20of%20choreographies%20show)[portal.findresearcher.sdu.dk](https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming#:~:text=software,when%20dealing%20with%20such%20nontrivial)
- John Högberg, "A brief introduction to BEAM," Erlang/OTP Blog, Oct. 20, 2020. (Description of BEAM's concurrency model and actor-model characteristics)[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=The%20BEAM%27s%20concurrency%20model%2C%20grounded,maintainable%20systems%20much%20more%20effortless)[happihacking.com](https://happihacking.com/blog/posts/2024/designing_concurrency/#:~:text=BEAM%20handles%20concurrency%20through%20lightweight,fault%20tolerance%20and%20system%20reliability)
- **Additional references:** Choreographic Programming Workshop 2024 materials, and various language implementations (Choral for Java, MultiChor for Haskell, etc.)[lambdaland.org](https://lambdaland.org/files/2025_programming_chorex.pdf#:~:text=Languages%20that%20support%20choreographic%20programming,Haskell%2C%20introduces%20a%20dynamic%20approach) which illustrate the growing interest in this paradigm across different ecosystemsi.
