# LALR(1) Parsing Explained (Beginner-Friendly)

## ðŸ§  What Is LALR(1) Parsing?

**LALR(1)** stands for:

> **Look-Ahead LR with 1 token of lookahead**

Itâ€™s a type of **bottom-up parser**, meaning it **starts from the input tokens** and works **upward** toward building the syntax tree that represents the programâ€™s grammar.

Itâ€™s one of the most **common parser types** used in programming language compilers (e.g., Yacc, Bison).

---

## ðŸŒ³ The Big Picture: Parsing Pipeline

```
source code
   â†“
tokenizer (lexer)
   â†“
sequence of tokens
   â†“
parser (LALR(1))
   â†“
abstract syntax tree (AST)
```

**Goal:** Determine if the token sequence follows the grammar and build the AST.

---

## ðŸ“˜ Example Grammar

```
E â†’ E + T | T
T â†’ T * F | F
F â†’ (E) | id
```

This describes simple arithmetic with addition, multiplication, and identifiers.

---

## ðŸ§© Step 1: LR(0) Items

An **LR item** is a grammar rule with a â€œdotâ€ (Â·) showing how much weâ€™ve recognized.

Example:

```
E â†’ E Â· + T   // means weâ€™ve parsed the left E and now expect "+"
```

The parser builds **states** based on these items.

---

## ðŸ§± Step 2: Building States (Simplified Idea)

Each **state** represents possible parser situations.

| State | Meaning Example |
|--------|-----------------|
| S0 | starting point: we expect an `E` |
| S1 | we have parsed `E`, maybe see `+` next |
| S2 | we are parsing `T` |
| S3 | we have parsed `F`, may see `*` next |

Each state defines what **actions** to take:
- **Shift**: read the next token
- **Reduce**: apply a rule (collapse right-hand side to left-hand side)
- **Goto**: move to a new state after reduction

---

## âš™ï¸ Step 3: Add Lookahead (LALR(1))

The **â€œ(1)â€** means:
> The parser looks **1 token ahead** to decide what to do.

Without lookahead, you might have ambiguity like this:

```
E â†’ E + T | T
T â†’ T * F | F
```

If you see `id`, should we reduce `F â†’ id` or wait for a `*` or `+`?  
The **lookahead token** (like `+` or `*`) helps decide.

---

## ðŸªœ Step 4: Merge States (LALR Optimization)

The **LALR** version merges similar **LR(1)** states that only differ in lookahead sets.

This reduces the number of states â€” **more efficient** but still **unambiguous** for most programming languages.

---

## ðŸ§® Step 5: Example Parsing Walkthrough

Letâ€™s parse:  
```
id + id * id
```

### Tokens
```
[id, +, id, *, id]
```

### Simplified Parse Table Actions
| State | Token | Action |
|--------|--------|--------|
| S0 | id | Shift â†’ S5 |
| S5 | + | Reduce Fâ†’id |
| S3 | + | Reduce Tâ†’F |
| S1 | + | Shift + |
| ... | ... | ... |

*(The actual table is large, but tools like Yacc/Bison generate it automatically.)*

---

## ðŸ§© Pseudo-Code (Simplified Parser Loop)

```pseudo
stack = [0]  // initial state
input = tokens + [EOF]

while true:
    state = top(stack)
    token = peek(input)
    action = parse_table[state, token]

    if action == "shift s":
        push(token)
        push(s)
        consume(input)

    else if action == "reduce A â†’ Î²":
        pop(2 * len(Î²))   // remove symbols and states
        t = top(stack)
        push(A)
        push(goto_table[t, A])

    else if action == "accept":
        print("Parsing successful")
        break

    else:
        error("Unexpected token: " + token)
```

---

## ðŸŒ² Mermaid Diagram: LALR(1) State Flow (Simplified)

```mermaid
stateDiagram-v2
    [*] --> S0: start
    S0 --> S5: on 'id'
    S5 --> S1: reduce Fâ†’id
    S1 --> S2: reduce Tâ†’F
    S2 --> S3: reduce Eâ†’T
    S3 --> S4: on '+'
    S4 --> S5: on 'id'
    S5 --> [*]: accept
```

This is highly simplified but gives the sense of **state transitions** and **reductions**.

---

## ðŸ§­ Summary

| Concept | Meaning |
|----------|----------|
| **LR** | Left-to-right scan, Rightmost derivation in reverse |
| **LALR(1)** | Optimized LR(1) with merged states, 1-token lookahead |
| **Advantage** | Efficient, deterministic, good for most programming languages |
| **Used in** | Yacc, Bison, Menhir, Goâ€™s `go tool yacc`, Rustâ€™s `lalrpop` |

---

## ðŸ§° In Practice

You rarely build these tables by hand â€” instead, use a parser generator:

```bash
yacc -d expr.y
cc y.tab.c -o parser
```

or in Rust:

```rust
lalrpop src/parser.lalrpop
```

These tools create a parser that executes exactly like the pseudo-code loop above.

