**Robinson's Unification Algorithm: A High-Level Technical Overview**

_Illustration of unification:_ A substitution σ applied to two terms can make them identical. In the triangle diagram, two original terms _t₁_ and _t₂_ (bottom) become equal at the top after applying σ (i.e. _t₁σ = t₂σ_). Unification finds such a σ when it exists[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Unification%20is%20the%20process%20of,which%20a%20unifier%20exists%20are).

**Unification in Logic Programming**

**Unification** is the process of determining whether two expressions can be made identical by applying a suitable substitution to their terms[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Unification%20is%20the%20process%20of,which%20a%20unifier%20exists%20are). In practical terms, unification tries to **solve equations between symbolic terms** by finding values for variables that make the two sides exactly the same. In logic programming (e.g. Prolog), unification is fundamental - it's the mechanism that binds variables when matching a goal with a rule or fact. For example, in Prolog the = operator performs first-order syntactic unification; it binds the contents of variables as a one-time assignment to make two terms equal[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=Prolog%2C%20the%20equality%20symbol%20,time%20assignment). Robinson's 1965 algorithm was the first machine-oriented method to do this automatically, and it became a cornerstone of automated reasoning (it was used in his resolution theorem prover to systematically handle variable instantiations)[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=match%20at%20L1036%205.%20,14).

**Terms: Variables, Constants, and Function Symbols**

Unification operates on **terms** in first-order logic. A term can be:

- a **variable** (e.g. X),
- a **constant** (a symbol that denotes a specific object, like a or 42), or
- a **compound term** which is a _function symbol_ applied to a sequence of argument terms[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=t%20%E2%88%88%20T%20iff%20t,substitution%20%CF%83%20to%20a%20term). Each function symbol has an **arity** (a fixed number of arguments). For example, f(x, g(y)) is a compound term with outer function symbol f of arity 2, and g(y) as one of its subterms. (A constant can be seen as a function of arity 0[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=algorithm%20terminates%20with%20%E2%8A%A5%3B%20other,function%20symbols%20having%20zero%20arguments).) Terms thus have a recursive structure: they consist of a root symbol (variable, constant, or function) and, if that root is a function, a list of subterms.

When we talk about making two terms "identical," we mean structurally identical - they have the same shape and symbols once variables are replaced appropriately. If two terms are identical already, they trivially unify (no substitution needed). But if not, the unification algorithm will try to **find a substitution** that makes their structures and all components match exactly.

**Substitutions and How They Are Applied**

A **substitution** is essentially a mapping from variables to terms[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=A%20substitution%20%CF%83%20is%20a,substitution%20%CF%83%20to%20a%20term). We often write a substitution as a set of pairs like {X ↦ t, Y ↦ u, …}, meaning variable X is replaced by term _t_, Y is replaced by _u_, and so on. Applying a substitution σ to a term (notated σ(_t_)) means **replacing each variable in _t_ that has a mapping in σ with its corresponding term**. For example, applying σ = { X ↦ f(a), Y ↦ Z } to the term p(X,Y) yields σ(p(X,Y)) = p(f(a), Z), since X is replaced by f(a) and Y by Z. The result of applying a substitution to a term is often called an **instance** of the term[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=t%2C%20the%20resulting%20term%20%CF%83,a). If σ makes two terms _t₁_ and _t₂_ identical (i.e. σ(_t₁_) = σ(_t₂_)), then σ is called a **unifier** of _t₁_ and _t₂_[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Unification%20is%20the%20process%20of,which%20a%20unifier%20exists%20are). In particular, Robinson's algorithm, if it succeeds, produces a **most general unifier (MGU)** - a unifier that is as general as possible (not making unnecessary specific choices) such that any other unifier for the terms can be seen as a specialization of the MGU[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=called%20unifiable,unification%20algorithms%20is%20to%20find). In other words, the algorithm finds a substitution that solves the matching problem in the most general way, allowing a correct and flexible implementation of logic programming semantics.

It's important to note that if multiple substitutions are applied in sequence, they can be **composed** or _cascaded_ into a single equivalent substitution[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Cascading%20substitutions%20To%20emulate%20the,substitutions%20in%20sequence%2C%20they%20can)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=each%20replacement%20term%2C%20as%20well,%E2%8A%86%20%CF%83.%20Since). Robinson's algorithm takes care of this by progressively building up a substitution. Whenever a new binding is found during unification, it is immediately applied to the remaining terms (and accumulated with previous bindings) so that subsequent steps work with updated terms. This avoids confusion and ensures that by the end of the process, we have one consolidated substitution that accounts for all variable bindings.

**Robinson's Unification Algorithm (Recursive Process)**

At a high level, Robinson's unification algorithm works by recursively traversing the two terms to be unified, looking for inconsistencies or variable bindings that can make the terms equal. The algorithm either succeeds, yielding an MGU substitution, or fails if no unifier exists. Here is the **main process** broken into steps and cases:

- **Trivial Case (Already Equal):** If the two terms are **identical** (same variable, or same constant, or same function with identical subterms), no new substitution is needed - they are already unified. The algorithm can continue to the next pair or conclude successfully if this was the only pair[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=3%20THEN%204%20IF%20x%3Dt,t%5Cx%5D%7D%3B%2010%20FI). For example, X and X unify trivially with no substitution, as do foo(…) and foo(…) if all sub-parts match.
- **Variable Case:** If at least one of the terms is a **variable** (say X) and the other is some term t:
  - If X and t are the **same variable** (e.g. unifying X with X), no action is needed (similar to the trivial case above)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=2%20IF%20one%20of%20the,t%5Cx).
  - Otherwise, we attempt to bind the variable to the other term. **Occurs-check** is crucial here: the algorithm checks whether the variable appears _anywhere inside_ term t. If it does, then binding X to t would create a recursive, impossible structure (for example, attempting to bind X = f(X, …) would mean X contains itself) - this is not allowed. This test is known as the **occurs-check**, and if it fails (meaning the variable _does occur_ in the term), then the unification **fails** at this point[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=7%20IF%20the%20variable%20x,true%3B%20unifier%20%3A%3D)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=both%20terms%20are%20variables%20and,and%20a%20substitution%20replacing%204). If the occurs-check passes (the variable does not appear in t), we **bind** X to t by adding the substitution {X ↦ t} to our unifier[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=both%20terms%20are%20variables%20and,and%20a%20substitution%20replacing%204)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=the%20term%20with%20the%20variable,different%20functions%20are%20never%20unifiable). We then apply this substitution immediately to any remaining equations or term pairs we need to unify, so that future comparisons take this new binding into account. (In an Erlang implementation, this step would involve storing the binding for X and ensuring any occurrence of X in the yet-to-be-unified parts of the terms is replaced by t.)
- **Constant Case:** If both terms are **constants** (zero-arity symbols) or atoms:
  - If the constants are exactly the **same symbol**, unification succeeds for this pair (no substitution needed for this pair, but continue checking other parts if any).
  - If they are **different constants**, then unification **fails** (there is no way to make two distinct atoms equal)[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=1,So). For example, apple cannot be unified with banana since they are different constant symbols.
- **Compound Term (Function) Case:** If both terms are **compound terms** (i.e. function symbols with arguments):
  - First, compare the function symbols (and their arity) at the root of each term. If the function names are **different** or if the number of arguments differs, unification cannot proceed and fails at this point[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=the%20term%20with%20the%20variable,different%20functions%20are%20never%20unifiable). For instance, f(X, Y) cannot unify with g(A, B) because f ≠ g, and h(X) cannot unify with h(Y, Z) because the arity (1 vs 2) doesn't match.
  - If the function symbols are the **same and arities match**, then the algorithm attempts to unify each pair of corresponding **arguments** recursively. This means we create subproblems for each argument position (e.g. unify term₁'s first argument with term₂'s first argument, second argument with second argument, and so on)[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=2,20). Each of those sub-unifications will itself produce either a failure or a substitution (unifier) for that pair of subterms. If any argument pair fails to unify, then the whole unification fails (the two original terms cannot be made identical)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=and%20terminate%20the%20algorithm%20,line%2019). If all argument pairs unify, we then **combine all the substitutions** found for each pair into a single substitution for the whole term. In practice, as each argument's unification returns a substitution, the algorithm composes it with the current overall substitution (applying the new bindings to any future comparisons) before moving on[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=and%20terminate%20the%20algorithm%20,line%2019). By the end, if none of the argument unifications failed, we have a cumulative substitution that makes every part of term₁ and term₂ identical.

The process above is inherently **recursive**: whenever compound subterms are encountered, the algorithm calls itself on those subterms. This fits naturally with an implementation in a functional language like Erlang - you can pattern-match on the form of the terms (variable vs constant vs tuple for function symbol) and recurse accordingly. The algorithm returns a result indicating either _"not unifiable"_ (failure) or a substitution that is the MGU of the two input terms[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Algorithm%20ROBINSON_TREE%20%3A%20unify,1%20FUNCTION%20unify%28t1%2C%20t2).

**The Occurs-Check and Why It Matters**

The **occurs-check** is a small but crucial step in the algorithm that ensures soundness. It prevents a variable from being unified with a term that contains that same variable. In simpler terms, when trying to bind X = t, we check that X does not appear inside t[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=7%20IF%20the%20variable%20x,true%3B%20unifier%20%3A%3D). If it does, unification fails immediately. This prevents the creation of **cyclic terms** (infinitely recursive structures). For example, without an occurs-check, unifying X with f(X) would misleadingly succeed, making X equal to a term that contains itself. In an implementation that would effectively create an **infinite term** (a structure that references itself), which is not a valid first-order term. Indeed, the occurs-check will correctly refuse to bind X = f(X) (and similar cases) as unsolvable.

Why does this matter? Without the occurs-check, the unification algorithm can derive **unsound or non-terminating results**. A classic example is the Prolog query X = f(X). If a Prolog system omits the occurs-check (as some do for efficiency), this query will succeed, binding X to a cyclic structure (a term that infinitely references itself)[en.wikipedia.org](https://en.wikipedia.org/wiki/Occurs_check#:~:text=In%20theorem%20proving%20%2C%20unification,with). Such a solution has no meaning in standard first-order logic (it has no counterpart in the Herbrand universe of possible values) and can lead to logical contradictions. In theorem proving, omitting the occurs-check can even make an invalid statement seem provable by erroneously introducing infinite terms[en.wikipedia.org](https://en.wikipedia.org/wiki/Occurs_check#:~:text=In%20theorem%20proving%20%2C%20unification,displaystyle). Thus, the occurs-check is essential for **logical soundness**: it ensures that unification only produces well-founded substitutions. (Note: Many Prolog implementations skip the occurs-check for performance reasons, but they then allow _rational trees_ or cyclic structures, accepting the trade-off that the resolution procedure may work with infinite terms[en.wikipedia.org](https://en.wikipedia.org/wiki/Occurs_check#:~:text=Prolog%20implementations%20usually%20omit%20the,term%20unification%2C%20runtime%20shrinks%20to). For a clean implementation in Erlang or any logic engine, it's advisable to include the occurs-check unless you explicitly plan to support cyclic terms.)

**Failure Conditions and Handling**

Throughout the algorithm, there are specific points where unification **can fail**, meaning no valid substitution exists to make the terms identical. To implement the algorithm correctly, a developer must check for these failure conditions:

- **Constant mismatch:** If we attempt to unify two constants (atoms) that are not the same symbol, it is an immediate failure - e.g. foo ≐ bar cannot be resolved[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=1,So).
- **Function symbol or arity mismatch:** If two compound terms have different function symbols at the root or different arities (lengths of argument list), they cannot unify[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=the%20term%20with%20the%20variable,different%20functions%20are%20never%20unifiable). The structures are fundamentally incompatible (e.g. one term is a 3-tuple and the other is a 2-tuple, or one starts with f and the other with g).
- **Occurs-check failure:** As discussed, if a variable needs to unify with a term that contains that variable, the algorithm reports failure[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=7%20IF%20the%20variable%20x,true%3B%20unifier%20%3A%3D). This is a structural self-reference conflict.
- **Conflict in substitutions:** This is a more implicit condition that arises during recursion. For example, if during the process we derived that X must equal a and also that X must equal b (with a and b distinct), then no single substitution can satisfy both - the algorithm will eventually catch this when trying to unify a with b and fail[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=1,So). Essentially, any time we get a **contradiction** - such as needing one term to simultaneously be two different constants or two different structures - it triggers failure. The algorithm detects these when attempting to unify non-matching symbols, as in the earlier steps.

When a failure is detected in any of the above situations, the algorithm typically **backtracks or stops** (depending on the context - in pure unification it stops with "not unifiable"). In an implementation, you'd propagate an error or an indication of failure up the recursive calls. If unification is one part of a larger resolution or type-inference process, a failure would signal that the current attempt to match terms should be abandoned. Robinson's algorithm, being deterministic for a given pair of terms, will either find the MGU or determine that no unifier exists (failure)[cip.ifi.lmu.de](https://www.cip.ifi.lmu.de/~sprinz/sprinz_2021_unification.pdf#:~:text=Algorithm%20ROBINSON_TREE%20%3A%20unify,1%20FUNCTION%20unify%28t1%2C%20t2).

**Summary:** Robinson's unification algorithm systematically goes through the structure of two terms, binding variables to terms when possible, and ensuring the structures match at every point. It uses the occurs-check to avoid nonsensical cyclic bindings and reports failure when it finds any irreconcilable difference. This high-level understanding should equip a senior developer to implement the algorithm in Erlang's core language: by using pattern matching to distinguish cases (variable, constant, compound) and recursion to handle subterms, one can translate the above logic into code. The result will be a function that either returns a substitution (mapping of variables to terms) making the input terms equal, or indicates that no unifier exists. This forms the backbone of unification in logic programming, enabling capabilities like pattern matching in Prolog or type inference in compilers[en.wikipedia.org](https://en.wikipedia.org/wiki/Unification_%28computer_science%29#:~:text=Like%20for%20Prolog%2C%20an%20algorithm,type%20inference%20can%20be%20given), all rooted in the elegant process of making two terms identical through substitution.
