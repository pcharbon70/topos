**Topos Build System and Compilation Design**

**Overview**

We propose a build system for Topos that fully exploits BEAM's strengths (concurrency, distribution) while incorporating modern compiler techniques. The goal is to achieve fast, efficient builds through **incremental compilation**, **parallel compilation**, and **caching**, support **cross-compilation** to multiple BEAM/OTP versions, provide hooks for **custom build steps**, and even enable **profile-guided optimization (PGO)**. In addition, developer tooling like an interactive **REPL** with documentation introspection will improve productivity. All these features will be designed in alignment with Topos's module system and overall language principles.

**Incremental Compilation and Fine-Grained Dependencies**

To support rapid development, Topos's compiler will implement **incremental compilation** with fine-grained dependency tracking. Rather than rebuilding everything on each change, the compiler tracks dependencies between modules (and possibly finer units) so that only affected components are recompiled when code changes.

- **Module-Level Incrementality:** The compiler treats each Topos module as a separate compilation unit (per our module system design). It records which modules depend on which others (e.g. if module A imports B). When a file changes, the build system invalidates that module's build artifact and any modules that depend on its _interface_. Unchanged modules are not recompiled, saving time.
- **Interface vs Implementation Changes:** The dependency tracking is fine-grained enough to distinguish interface changes from internal changes. For example, if a module's public API (types, functions signatures) remains the same and only the implementation changes, we can avoid recompiling modules that import it[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=This%20fine,depend%20on%20the%20parse%20result). This is similar to how some ML-family compilers use interface files to skip recompilation of dependents when only function bodies change. By caching and reusing previous compilation results whenever safe, we minimize redundant work.
- **Build Artifacts Cache:** The compiler will cache intermediate results (parsed ASTs, type-check results, etc.) from previous builds. On a new build, it will verify if those cached results are still valid given the current source. Thanks to fine-grained dependency tracking, the build can even detect changes that have _no semantic effect_ and reuse prior results[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=This%20fine,depend%20on%20the%20parse%20result). For instance, a purely cosmetic change (like whitespace or comments) might trigger a re-parse, but since the AST and public interface are unchanged, downstream compilation steps can reuse the previous outputs[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=This%20fine,depend%20on%20the%20parse%20result).
- **Query-Based Compilation:** We can adopt a _query-based compiler architecture_ (inspired by systems like Haskell's Shake/Rock) to enable robust incremental builds. In such a design, the compiler's tasks (parsing, type checking, code generation for each module, etc.) are formulated as _queries_ with explicit dependencies. A centralized cache memoizes query results, so if a query (e.g. "type-check module X") is requested again with the same inputs, it returns the cached result[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=Verifying%20dependencies%20and%20reusing%20state). This architecture naturally supports incremental compilation by reusing results of unchanged queries, and it lays the groundwork for parallel execution as well.

**Parallel Compilation on Multiple Cores**

Topos's build should leverage all available CPU cores to speed up compilation. The BEAM's ability to run many processes concurrently fits perfectly here: we can spawn compilation tasks in parallel for independent modules.

- **Module Dependency Graph:** The build tool constructs a dependency graph of modules. Any modules that do not depend on each other (or whose dependencies are already compiled) can be compiled concurrently. This means if your project has many modules in different parts of the graph, the compiler will utilize multiple cores to compile them in parallel.
- **BEAM Concurrency for Compilation:** The compilation pipeline can be implemented as a set of BEAM processes or scheduler tasks, each handling a compilation unit. BEAM's lightweight processes and scheduling ensure these compile tasks run concurrently across all cores. For example, the compiler could spawn a process per module (or per compilation query), and the BEAM VM will schedule them on available CPU cores. This approach is robust and scales with core count.
- **Query Parallelism:** In the query-based model mentioned, parallelism comes naturally - since any query can be executed when needed, the build system can _fire off multiple queries in parallel_ as long as their dependencies are satisfied[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=Query,be%20type%20checked%20in%20parallel). In fact, an existing implementation notes that query-based compilers are "surprisingly easy to parallelise" because once results are memoized, independent queries can run simultaneously without interference[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=Query,be%20type%20checked%20in%20parallel). Topos's compiler will, by default, type-check and compile all modules in parallel whenever possible[ollef.github.io](https://ollef.github.io/blog/posts/query-based-compilers.html#:~:text=Query,be%20type%20checked%20in%20parallel).
- **Task Scheduling:** We will include a scheduler in the build system that respects dependencies but maximizes concurrency. It will function similarly to a build tool like make or Bazel, but at the granularity of Topos modules/queries. Developers should see near-linear speedups in build times as they add cores, especially for large projects divided into many modules.

**Cross-Compilation for Different BEAM Versions**

Because Topos targets the BEAM runtime, we must account for differences between BEAM/OTP versions. The build system will support **cross-compiling** or targeting a specific OTP version, which is crucial for compatibility and deployment in heterogeneous environments.

- **BEAM Bytecode Compatibility:** Generally, Erlang bytecode (.beam files) is portable across operating systems, and backward compatibility is maintained for a few OTP releases[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=Provided%20that%20those%20platforms%20have,files%20and%20JVM). A .beam compiled on one platform can run on another (like compile on Mac, run on Linux) as long as the OTP version is within the compatibility window[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=Provided%20that%20those%20platforms%20have,files%20and%20JVM). Specifically, OTP promises that beam files are usually backward-compatible across _two_ major releases[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=bytecode.%20Just%20like%20,and%20JVM). For example, code compiled with OTP R16 should run on OTP 17 or 18[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=bytecode.%20Just%20like%20,and%20JVM).
- **Target OTP Version Setting:** To extend this, Topos's compiler will allow specifying a _target OTP release_ (or minimum version). This setting will ensure the generated bytecode and used features do not exceed the specified version's capabilities. For instance, if targeting OTP 25, the compiler will avoid emitting any newer opcodes introduced in OTP 26. This might involve selecting an appropriate BEAM instruction set or toggling certain optimizations. Essentially, the compiler will have profiles for each supported OTP version's bytecode.
- **Multiple Backend Codegens:** Under the hood, we might maintain code generation strategies for different OTP versions. If necessary, the build tool could even invoke an older version of the Erlang compiler for final assembly of bytecode to guarantee compatibility. However, since Topos is a standalone language, it likely has its own code emitter for BEAM. That emitter will be version-aware.
- **Cross-Compilation Workflows:** In practice, a developer could build their Topos project on a machine with OTP 26 but target OTP 24 for deployment. The build system will produce .beam files compatible with OTP 24 (perhaps by limiting to OTP 24's instruction set). This obviates the need to actually run OTP 24 during compilation - though we will test that the output works on the older VM. For projects that include native components (NIFs), the build tool will facilitate cross-compiling those as well by integrating with build toolchains for the target platform, similar to how Erlang releases include cross-compiled NIFs[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=While%20Erlang%20%60beams%60%20are%20cross,that%20can%20be%20platform%20dependent)[stackoverflow.com](https://stackoverflow.com/questions/39082661/make-an-erlang-app-release-on-a-mac-to-run-it-on-linux#:~:text=1).
- **Testing on Multiple OTPs:** As part of cross-version support, our CI integration can include testing the build on multiple OTP versions. The build system can fetch and use multiple Erlang/OTP toolchains as needed. This ensures Topos code truly runs on the intended targets.

Overall, these measures will make Topos friendly for environments where the BEAM version can vary (for example, an organization slow to upgrade OTP). Developers can explicitly ensure compatibility through the build configuration.

**Build Caching and Distributed Builds**

To further accelerate builds, Topos will support robust **build caching**. This involves reusing compiled artifacts and even sharing them across machines.

- **Local Build Cache:** On each developer's machine, the build system will cache compilation outputs keyed by content. If nothing relevant changed since the last build (based on file checksums or a similar mechanism), a rebuild can skip straight to using the previous artifact. For example, if module Utils hasn't changed and none of its dependencies changed, the cached .beam for Utils can be reused without recompiling. This is conceptually similar to how mix and rebar3 leave compiled beam files in a \_build directory and only rebuild changed ones. We will store not just the final beam, but possibly intermediate states (parsed AST, etc.) in case it helps resume work faster.
- **Distributed Build Cache:** We can take caching a step further by enabling a **shared cache** across a team or CI servers. Inspired by tools like Gradle's build cache, we will allow configuring a remote cache server. When a build produces an artifact (e.g., a .beam for a specific version of a module), it can upload it to the cache. Other developers (or CI agents) running the same build later can download that artifact instead of recompiling, as long as the source and compiler options match. This can dramatically speed up clean builds or builds on CI by reusing work done elsewhere[docs.gradle.org](https://docs.gradle.org/current/userguide/build_cache.html#:~:text=The%20Gradle%20build%20cache%20is,locally%20or)[gradle.com](https://gradle.com/develocity/product/build-cache/#:~:text=Develocity%20Build%20Cache%20,The).
- **Content-Addressable Caching:** Each compiled artifact will be addressed by a hash of its inputs (source code, dependencies' signatures, compiler version, etc.). This ensures that only truly identical inputs will reuse the same artifact. With fine-grained dependency tracking, the cache keys can be very precise. For example, changing one function in a module will produce a different hash for that module's artifact, but modules unrelated to that change still match their cache entries and need not be rebuilt.
- **Hermetic Builds for Reproducibility:** To make caching reliable, Topos builds should be **hermetic** and reproducible. That is, given the same input sources and configuration, the compiler produces identical outputs. We will avoid embedding nondeterministic data (timestamps, random IDs) in outputs. This approach, used by build systems like Bazel, maximizes cache hits[bazel.build](https://bazel.build/reference/be/general#:~:text=,lead%20to%20unexpected%20build%20behavior)[bazel.build](https://bazel.build/reference/be/general#:~:text=match%20at%20L687%20the%20genrule,should%20emit%20good%20error%20messages). The build system will also isolate external influences: for instance, if custom build steps run commands, we'll encourage them to be pure in terms of inputs/outputs (no reading from undefined environment or network, etc., unless explicitly declared)[bazel.build](https://bazel.build/reference/be/general#:~:text=A%20,defined%20Bash%20command)[bazel.build](https://bazel.build/reference/be/general#:~:text=Note%20that%20genrule%20requires%20a,tool%2C%20consider%20using%20run_binary%20instead).
- **Integration with Package Management:** Topos's package manager (as outlined in our packages research) can also benefit from caching. Dependencies (third-party Topos libraries) once compiled can be cached and even distributed in compiled form. Imagine pulling a library from a repository along with a precompiled beam artifact for your target OTP; the build could skip compiling that dependency entirely if the hash matches. This is akin to how some systems use "binary artifacts" to speed up dependency management.

In summary, build caching (both local and distributed) will greatly reduce build times, especially in large codebases or monorepos. Developers experience faster rebuilds, and CI pipelines run quicker by not repeating work done on developer machines or other CI runs[gradle.com](https://gradle.com/develocity/product/build-cache/#:~:text=Develocity%20Build%20Cache%20,The).

**Custom Build Steps (Code Generation and Assets)**

Real-world projects often require custom build steps - e.g., generating code from DSLs/IDLs, bundling static assets, or other pre/post-processing. Topos's build system will be designed for **extensibility**, allowing custom build tasks to integrate seamlessly.

- **Code Generation Hooks:** Users will be able to define steps that run before or during compilation to generate source code. For instance, if your project uses an IDL to define data schemas, you could have a codegen step that produces Topos source files from the IDL. The build tool will then treat those generated files as part of the compilation inputs. We might provide a DSL or configuration (similar to a Build.toml or mix.exs) where you can specify, for example, "run toposgen --in schema.idl --out schema.morph before compiling". These hooks would ensure the generated code is up-to-date each build.
- **Asset Pipeline:** For projects that need to bundle non-code assets (like templates, config files, etc.), the build system can incorporate those as well. For example, one could define a custom step to compress images or compile CSS if Topos is used in a web context. While this isn't core to the language, having a flexible build tool means Topos can be used in varied domains without requiring external build scripts.
- **Mix-style Compilers and Tasks:** The design here could take inspiration from Elixir's Mix compiler pipelines. Mix allows custom compilers to be added to the build pipeline - for example, it has compilers for .yecc and .leex files (parser generators) which run before Elixir compilation. Topos could have a similar concept: the build tool will recognize various file types or tasks and execute them in order. We might provide an API for writing custom compile tasks (in Topos or Erlang) that the build tool can invoke.
- **Generic Command Hooks:** In cases where deeper integration isn't needed, the build configuration might simply specify a shell command to run at a certain phase. This is analogous to Bazel's genrule, which "generates one or more files using a user-defined command" when no built-in rule fits[bazel.build](https://bazel.build/reference/be/general#:~:text=A%20,defined%20Bash%20command). Topos's build could have a "run this command to produce outputs" step for flexibility. We will caution to keep such commands hermetic for caching (e.g., list explicit inputs/outputs so the build knows when to rerun it, similarly to how Bazel requires declaring inputs for genrules[bazel.build](https://bazel.build/reference/be/general#:~:text=For%20genrules%2C%20the%20build%20system,variables%20that)).
- **Integration with Modules System:** All custom steps will be designed to align with Topos's module and package system. For example, if a codegen step produces a new Topos module, it should declare that module (name, version) such that the build tool can treat it like any other source module (with dependencies, etc.). Our module research emphasizes clarity and encapsulation, so generated modules should not violate those principles - they'll behave like normal modules that just happen to be auto-generated.
- **Examples:** As a use case, consider a domain-specific language embedded in Topos (per our DSL research). We might implement that DSL via a preprocess step: a Topos macro or an external tool transforms DSL code into core Topos code. The build system would run this transformation automatically. Another example is documentation generation: perhaps we have a step to extract documentation comments and produce reference docs or a website. While not directly "compilation", the build tool could orchestrate this as a custom task (e.g., topos doc command that the build can invoke as part of a release build).

By making the build process extensible, we ensure Topos can accommodate various project needs without resorting to external build systems. All tasks can run in the context of Topos's own build tool, benefiting from the same parallelism and caching infrastructure.

**Profile-Guided Optimization (PGO)**

For high-performance scenarios, Topos will explore **profile-guided optimization**. PGO involves using runtime profiling information to guide the compiler in producing more optimized code[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=Rather%20than%20programmer,the%20profiling%20stage%20must%20be). While PGO is traditionally applied in ahead-of-time compiled languages like C/C++, we can adapt the concept to Topos's BEAM compilation.

- **How PGO Works:** In a PGO workflow, the program is first compiled in a special _instrumented_ mode and run on a representative workload. The runtime collects data on which functions are hot (frequently executed), which branches are taken often, etc. The compiler then uses this profile data in a second compilation pass to optimize the code paths that the program spends the most time in[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=Rather%20than%20programmer,the%20profiling%20stage%20must%20be)[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=accesses%20profile%20data%20from%20a,build%20instead%20of%20improving%20it). This leads to better overall performance because the compiler can make informed decisions rather than generic assumptions. For example, it might inline a function that is proven hot, or lay out code to improve instruction cache usage based on hot paths.
- **Applying PGO to BEAM Code:** Since Topos ultimately runs on the BEAM, we are somewhat constrained by BEAM's execution model. However, there are still opportunities:
  - We could vary how we generate BEAM bytecode based on profiles. BEAM JIT already does some runtime optimization, but our compiler could emit different code patterns for hot functions (perhaps using slightly lower-level or more optimized constructs if available).
  - Topos might allow alternate strategies for certain high-level constructs (for instance, different data structure representations), and a profile could suggest which strategy to solidify at compile time.
  - Another angle is guiding inlining or specialization in the Topos compiler. With profile data, the compiler can inline functions that are frequently called or specialize generic code for the most common types or shapes of data encountered. This is analogous to feedback-directed inlining in other compilers[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=accesses%20profile%20data%20from%20a,build%20instead%20of%20improving%20it).
- **Tool Support:** The build system will provide commands to facilitate PGO:
  - _Instrumented Build:_ Compile the project with instrumentation enabled (this could flip a flag in the compiler to include counters or logs in the emitted code).
  - _Profile Run:_ Run the instrumented binary (perhaps via an automated test suite or sample input). This will output a profile data file (containing function call frequencies, branch taken frequencies, etc.).
  - _PGO Compile:_ Recompile the project using the collected profile as input. The compiler now tailors the code generation according to the profile (e.g., marking certain functions for inline or optimizing pattern match order based on frequency).
- **Benefits and Caveats:** Using PGO can yield performance gains by optimizing the _actual_ common cases of a program[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=accesses%20profile%20data%20from%20a,build%20instead%20of%20improving%20it). However, we must note that the profile needs to be representative; otherwise, one risks optimizing for the wrong scenarios and possibly regressing performance in the wild[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=frequently%2C%20and%20which%20areas%20are,build%20instead%20of%20improving%20it). The build tooling will allow easy re-profiling if the workload changes. It's also worth noting that PGO on BEAM might have diminishing returns compared to native code, because BEAM's JIT already performs some adaptive optimization[en.wikipedia.org](https://en.wikipedia.org/wiki/Profile-guided_optimization#:~:text=Just,information%20from%20the%20new%20profile). But for computationally heavy Topos code, PGO could still provide an edge by doing ahead-of-time what the JIT might only do at runtime, or by enabling optimizations the JIT doesn't cover.
- **Profile-Guided Concurrency Optimizations:** A unique opportunity on BEAM could be profiling cross-process communication patterns. Research exists on profile-guided optimization across Erlang process boundaries[researchgate.net](https://www.researchgate.net/publication/220947715_Profile-guided_optimization_across_process_boundaries#:~:text=PDF%20www,the%20effects%20of%20sending%20messages). Topos could leverage such ideas: for example, if profiling shows two processes frequently exchange messages, the compiler or runtime might co-locate them or even fuse them for performance. This is speculative, but a future Topos compiler could use profile data to decide how to distribute work across processes for optimal throughput (since Topos encourages a functional, concurrent style).

In summary, PGO is an advanced feature that we plan to incorporate into Topos's toolchain. It will be an optional, power-user tool-developers can stick to regular compilation and still get good performance, but those who need maximum speed can invest time in PGO to squeeze out extra performance in critical components.

**Interactive REPL with Documentation Introspection**

A productive development experience is vital. Topos will come with an interactive **REPL (Read-Eval-Print Loop)** that not only allows executing code on the fly but also introspecting documentation and other metadata - in line with our documentation research.

- **REPL Capabilities:** The Topos REPL will allow you to import modules, define functions, and test code snippets interactively. It's invaluable for quick experiments, debugging, and learning the language. Backed by the BEAM, the REPL can leverage hot code loading to redefine modules on the fly as you test changes, similar to how IEx (Elixir's REPL) or the Erlang shell works.
- **Documentation Introspection:** A standout feature will be the ability to query documentation from within the REPL. Topos modules and functions will carry documentation (docstrings) that the REPL can retrieve and display. This is made possible by storing docs in the compiled module metadata - following BEAM conventions like EEP-48 which standardizes an accessible documentation chunk in .beam files[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=This%20EEP%20proposes%20an%20official,tools%20that%20work%20across%20languages)[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=This%20EEP%20recognizes%20both%20options,a%20tool%20should). For example, a user could type something akin to ?doc ModuleName.function or a dedicated helper (like :doc ModuleName.function), and the REPL will print that function's documentation, usage examples, types, etc. This mirrors the h/1 helper in Elixir's IEx, which can "print the documentation of any module" by reading the Docs chunk[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=Currently%2C%20different%20programming%20languages%20and,for%20storing%20and%20accessing%20documentation).
- **Implementation:** When a module is compiled, if documentation is not stripped, the compiler will embed an annotated documentation structure (likely conforming to the EEP-48 format) into the beam. The REPL, upon a doc query, will look up the module's loaded bytecode (or beam file on disk), parse the Docs chunk and format the output for the user[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=This%20EEP%20recognizes%20both%20options,a%20tool%20should). Because Topos is a new language, we can ensure from the start that it adheres to the BEAM-wide documentation format standard, making this feature relatively straightforward to implement and also benefitting interoperability (e.g., an Erlang or Elixir IDE could potentially show docs for Topos code too).
- **Examples of Usage:** A developer using the Topos REPL might do:
  - :doc Math to see the documentation of the Math module (general description, perhaps listing of functions with short doc).
  - :doc Math.add to see the detailed docs for the add function in Math (including its type signature, explanation, and examples if provided).
  - They could also query types or other metadata if we extend introspection (for instance, :type SomeModule.SomeType could display a type definition). Documentation introspection can extend to types and even cross-language if documentation chunks from other BEAM languages are present[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=For%20example%2C%20Elixir%20and%20LFE,the%20documentation%20of%20any%20module).
- **REPL Introspection Beyond Docs:** While documentation is one focus, the REPL can also allow inspection of runtime values, types, and module information. Since Topos is based on category theory principles, an interactive environment might also help visualize or inspect categorical structures (for instance, quick composition of functions, etc.). This is more speculative, but the REPL could evolve into a powerful environment for exploring Topos programs.
- **Leverage of BEAM Tools:** We can integrate existing BEAM introspection tools in the REPL. For example, debugging utilities, process inspection (seeing what processes are running your code), etc., could be accessible. However, these are secondary to the main goal of a smooth interactive coding and documentation lookup experience.

By providing a rich REPL, we align with the principle that a language isn't just about compilation but also about interactive usage and learning. New Topos users will find it easy to discover library functionality by reading docs in the REPL, and experienced users will benefit from the rapid feedback loop it offers.

**Conclusion**

The design of Topos's build system and compilation pipeline combines the best ideas from modern language tooling while catering to the BEAM ecosystem's specifics. In summary, Topos will support **fast incremental builds**, **multi-core parallelism**, and **aggressive caching** to handle large projects efficiently. It will be flexible enough to handle **cross-OTP-version targets** and include **hooks for custom build tasks**, ensuring it can adapt to various project needs (from codegen to asset handling). Advanced features like **profile-guided optimization** show our intent to push performance boundaries where possible. Finally, a robust set of developer tools - especially an **interactive REPL with documentation introspection** - will make development in Topos productive and enjoyable, leveraging introspective features of the BEAM to provide help and information on demand[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=Currently%2C%20different%20programming%20languages%20and,for%20storing%20and%20accessing%20documentation)[erlang.org](https://www.erlang.org/eeps/eep-0048#:~:text=This%20EEP%20recognizes%20both%20options,a%20tool%20should).

All of these considerations are made while keeping Topos's theoretical foundations and module system in mind, ensuring that the build and compile process reinforces the language's principles (such as immutability, modularity, and clarity) rather than working against them. By combining proven concepts from existing languages (without merely copying one wholesale)[bazel.build](https://bazel.build/reference/be/general#:~:text=A%20,defined%20Bash%20command), Topos's build system will be a state-of-the-art platform for building reliable, efficient software on the BEAM.
