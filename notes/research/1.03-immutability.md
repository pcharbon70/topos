# Immutability in Topos
## Core Design Philosophy: Where Data Flows, Never Mutates

### 1. **Immutability as Foundation**

```topos
-- All bindings are immutable by default
flow example =
  let x = 5           -- x is immutably bound to 5
  let y = x + 1       -- creates new value, x unchanged
  let x = x + 1       -- ERROR: Cannot rebind immutable value
  in y

-- Explicit shadowing with 'shadow' keyword for clarity
flow calculate =
  let x = 5
  shadow x = x + 1    -- New binding, shadows previous x
  shadow x = x * 2    -- Another shadow, previous x no longer accessible
  in x                -- Returns 12
```

### 2. **Shapes are Immutable Records**

```topos
-- All shapes create immutable data
shape User = { 
  name: Text, 
  age: Natural,
  email: Email 
} deriving [Eq, Show]

-- Updates create new values via 'with' syntax
flow birthday : User -> User
flow birthday user = 
  user with { age = user.age + 1 }  -- Returns NEW User

-- Multiple updates
flow update_contact : Text -> Email -> User -> User
flow update_contact name email user =
  user with { 
    name = name,
    email = email 
  }  -- Creates new User with updated fields
```

### 3. **Optics for Nested Immutable Updates**

```topos
-- Lenses for deep updates without mutation
shape Address = { street: Text, city: Text, zip: Text }
shape Person = { name: Text, address: Address }

-- Auto-generated lenses for immutable updates
flow move : Text -> Person -> Person
flow move new_city = 
  Person.address.city.set new_city  -- Returns new Person

-- Compose lenses for complex updates
flow full_move : Address -> Person -> Person
flow full_move new_addr person =
  person 
  |> Person.address.set new_addr
  |> Person.updated_at.set now()

-- Prisms for sum type updates
shape Status = Active User | Inactive Reason | Pending
flow activate : User -> Status -> Status
flow activate user = Status.Active.set user  -- Safe update
```

### 4. **Immutable Collections with Persistent Data Structures**

```topos
-- All collections are persistent (structural sharing)
shape List a = Nil | Cons a (List a)
  implements [Persistent, Mappable, Chainable]

-- Collection operations return new collections
flow add_item : a -> List a -> List a
flow add_item item list = 
  item :: list  -- New list, shares structure with old

flow remove_first : List a -> Maybe (a, List a)
flow remove_first = match
  | Nil -> None
  | Cons x xs -> Some (x, xs)  -- xs is shared, not copied

-- Efficient immutable maps/sets
flow update_map : k -> v -> Map k v -> Map k v
flow update_map key value map =
  map.insert key value  -- Returns new map, O(log n)

-- Bulk updates with transients (controlled mutation)
flow bulk_update : List (k, v) -> Map k v -> Map k v
flow bulk_update updates map =
  transient map $ \t ->     -- Temporary mutable version
    for updates $ \(k, v) ->
      t.insert! k v          -- ! marks transient operation
    persistent t             -- Convert back to immutable
```

### 5. **Actor State is Immutable Between Messages**

```topos
-- Actors maintain immutable state
actor Counter = {
  -- State is immutable between messages
  shape State = { 
    count: Natural,
    history: List Natural  -- Immutable history
  } deriving [Immutable]  -- Explicit immutability marker
  
  shape Message = 
    | Increment 
    | Decrement 
    | Get 
    | Reset Natural
  
  flow init : Unit -> State
  flow init () = { count: 0, history: [] }
  
  -- Handle returns NEW state, never mutates
  flow handle : Message -> State -> (State, Maybe Reply)
  flow handle msg state = match msg
    | Increment -> 
        let new_count = state.count + 1
        let new_state = state with { 
          count = new_count,
          history = new_count :: state.history 
        }
        in (new_state, None)
    
    | Decrement -> 
        let new_count = state.count - 1
        let new_state = state with { 
          count = new_count,
          history = new_count :: state.history 
        }
        in (new_state, None)
    
    | Get -> 
        (state, Some state.count)  -- State unchanged
    
    | Reset n -> 
        let new_state = { 
          count: n, 
          history: n :: state.history 
        }
        in (new_state, None)
}
```

### 6. **Immutable Data Flow Pipelines**

```topos
-- Each step produces new immutable values
flow process_order : Order -> Result Order Error
flow process_order order =
  order
  |> validate_items        -- Returns new validated Order
  |> apply_discounts       -- Returns new Order with discounts
  |> calculate_tax         -- Returns new Order with tax
  |> add_shipping         -- Returns new Order with shipping
  |> finalize            -- Returns final immutable Order

-- Parallel processing with immutable data
flow parallel_transform : List Data -> List Result
flow parallel_transform items =
  items
  |> List.map spawn_process  -- Each process gets immutable copy
  |> Process.collect         -- Gather immutable results
  |> List.freeze            -- Mark explicitly as immutable
```

### 7. **Copy-on-Write Semantics for Large Data**

```topos
-- Efficient handling of large immutable structures
shape DataFrame = {
  columns: Map Text Column,
  index: Vector Natural
} deriving [Immutable, COW]  -- Copy-on-write optimization

flow add_column : Text -> Column -> DataFrame -> DataFrame
flow add_column name col df =
  df with { 
    columns = df.columns.insert name col  -- Structural sharing
  }

-- Lazy sequences for infinite immutable data
shape Stream a = Stream { 
  head: Lazy a, 
  tail: Lazy (Stream a) 
} deriving [Immutable]

flow fibonacci : Stream Natural
flow fibonacci = 
  let fib a b = Stream { 
    head: lazy a, 
    tail: lazy (fib b (a + b)) 
  }
  in fib 0 1
```

### 8. **Immutability Guarantees in Type System**

```topos
-- Types can be marked for immutability checking
trait Immutable a where
  -- Compiler verifies no mutation operations
  freeze : a -> Frozen a        -- Deep freeze
  thaw : Frozen a -> a          -- Create mutable working copy
  is_frozen : a -> Bool

-- Reference types with immutability tracking
shape Ref a = 
  | Immutable a       -- Cannot be changed
  | Mutable (Cell a)  -- Only in controlled contexts

-- STM for controlled concurrent updates
flow transfer : Natural -> Account -> Account -> STM (Account, Account)
flow transfer amount from to =
  atomic do
    from_balance <- read_tvar from.balance
    to_balance <- read_tvar to.balance
    -- Create new account states
    let new_from = from with { balance = from_balance - amount }
    let new_to = to with { balance = to_balance + amount }
    return (new_from, new_to)
```

### 9. **Temporal Values (Time-Travel Debugging)**

```topos
-- Immutability enables history tracking
shape Temporal a = {
  current: a,
  history: List (Timestamp, a),
  max_history: Natural
} deriving [Immutable]

flow update_temporal : a -> Temporal a -> Temporal a
flow update_temporal new_value temp =
  let timestamp = now()
  let new_history = (timestamp, temp.current) :: temp.history
                    |> List.take temp.max_history
  in temp with { 
    current = new_value,
    history = new_history 
  }

-- Rewind to previous state
flow rewind : Natural -> Temporal a -> Maybe (Temporal a)
flow rewind steps temp =
  temp.history
  |> List.drop (steps - 1)
  |> List.head
  |> Maybe.map \(_, value) -> 
       temp with { current = value }
```

### 10. **Compiler Optimizations for Immutability**

```topos
-- Compiler directives for optimization
{-# INLINE #-}  -- Safe because immutable
flow map_twice : (a -> b) -> (b -> c) -> List a -> List c
flow map_twice f g = 
  List.map f |> List.map g  -- Compiler can fuse into single pass

{-# STRICT #-}  -- Force evaluation of immutable value
flow sum : List Natural -> Natural
flow sum = List.fold (+) 0

-- Region-based memory management
flow process_large : HugeData -> Result
flow process_large data =
  region \r ->  -- Scoped memory region
    let temp1 = transform1 data in r  -- Immutable but region-allocated
    let temp2 = transform2 temp1 in r
    extract_result temp2  -- Only result escapes region
```

### 11. **Laws and Properties for Immutability**

```topos
-- Property-based tests for immutability
law immutable_update : User -> Text -> Bool
law immutable_update user new_name =
  let updated = user with { name = new_name }
  in user.name != new_name implies 
     user.email == updated.email &&
     user.age == updated.age

law collection_sharing : List a -> a -> Bool
law collection_sharing list item =
  let new_list = item :: list
  in list.tail == new_list.tail.tail  -- Structural sharing

-- Referential transparency guarantee
law referential_transparency : (a -> b) -> a -> Bool
law referential_transparency f x =
  f x == f x  -- Same input always produces same output
```

### Key Immutability Features Summary:

1. **No Assignment**: Only immutable bindings and explicit shadowing
2. **Persistent Data Structures**: All collections use structural sharing
3. **Update Syntax**: `with` keyword creates new values
4. **Optics**: Lenses and prisms for ergonomic nested updates
5. **Actor Isolation**: Each actor state is immutable between messages
6. **Copy-on-Write**: Automatic optimization for large structures
7. **Temporal Values**: Built-in history tracking leveraging immutability
8. **Compiler Guarantees**: Type system enforces immutability
9. **Region Memory**: Efficient handling of temporary immutable values
10. **Referential Transparency**: All functions are pure by default

This design ensures that data never mutates in place while maintaining ergonomic APIs and leveraging the BEAM's natural affinity for immutable message passing. The language makes immutability not just the default but the only option, with careful optimizations to ensure performance remains excellent.
