# Documentation in Topos
## Core Design Philosophy: Where Data Flows, Never Mutates, and Everything is Documented

### 1. **Documentation as Language Construct**

```topos
-- Documentation is REQUIRED and precedes definitions with 'doc'
doc "Represents a user in the system with immutable personal data"
doc fields {
  name: "The user's full legal name",
  age: "Age in years, must be 18 or older for legal reasons",
  email: "Primary contact email, must be verified"
}
doc examples """
  let user = { name: "Alice", age: 25, email: "alice@example.com" }
"""
shape User = { 
  name: Text, 
  age: Natural,
  email: Email 
} deriving [Eq, Show, Doc]  -- Doc trait enables introspection

-- Compiler ERROR if documentation is missing
shape Product = { name: Text }  -- ERROR: Missing required documentation

-- Functions require documentation of purpose, parameters, and return
doc "Increments a user's age, typically called on birthdays"
doc params {
  user: "The user whose age should be incremented"
}
doc returns "A new User instance with age incremented by 1"
doc complexity "O(1) - creates new record with structural sharing"
doc examples """
  let user = { name: "Bob", age: 30, email: "bob@test.com" }
  let older = birthday user  -- older.age == 31
"""
flow birthday : User -> User
flow birthday user = 
  user with { age = user.age + 1 }
```

### 2. **Rich Documentation Attributes**

```topos
-- Documentation supports multiple attributes
doc "Processes payment transactions immutably through the payment pipeline"
doc category "Financial"
doc since "1.0.0"
doc deprecated "2.0.0" reason: "Use process_payment_v2 for PCI compliance"
doc throws {
  InsufficientFunds: "When account balance is less than payment amount",
  NetworkTimeout: "When payment gateway doesn't respond within 30s",
  InvalidAccount: "When account number fails validation"
}
doc see_also [process_refund, validate_account, check_balance]
doc tags ["payment", "transaction", "critical"]
flow process_payment : Account -> Payment -> Result Transaction Error

-- Type classes document their laws
doc "Mappable allows transforming contents while preserving structure"
doc laws {
  identity: "map identity = identity",
  composition: "map (f . g) = map f . map g"
}
doc examples """
  List.map (+1) [1,2,3] == [2,3,4]
  Maybe.map toString (Some 5) == Some "5"
"""
trait Mappable f where
  doc "Transform the contents without changing the container structure"
  doc params {
    f: "Function to apply to each contained value",
    container: "The container whose contents to transform"
  }
  map : (a -> b) -> f a -> f b
```

### 3. **Introspection API**

```topos
-- Built-in introspection module
module Introspect = {
  -- Query documentation at runtime
  doc "Retrieves complete documentation for any documented value"
  flow get_doc : a -> Documentation
  flow get_doc value = 
    value.@@doc  -- @@ is the introspection operator
  
  -- Extract specific documentation fields
  doc "Gets the main description of a documented item"
  flow description : a -> Text
  flow description = get_doc >> Documentation.description
  
  doc "Gets all examples for a documented item"  
  flow examples : a -> List Text
  flow examples = get_doc >> Documentation.examples
  
  doc "Checks if an item is deprecated"
  flow is_deprecated : a -> Bool
  flow is_deprecated = get_doc >> Documentation.deprecated >> Maybe.is_some
}

-- Runtime documentation queries
flow explore_user =
  let doc = Introspect.get_doc User
  in IO.println doc.description
     |> (_ -> IO.println "Fields:")
     |> (_ -> Map.iter doc.fields $ \name desc ->
          IO.println $ "  " <> name <> ": " <> desc)

-- Pattern matching on documentation
flow check_complexity : (a -> b) -> Text
flow check_complexity func =
  match func.@@doc.complexity
  | Some "O(1)" -> "Constant time"
  | Some "O(n)" -> "Linear time"
  | Some "O(log n)" -> "Logarithmic time"
  | Some other -> "Complexity: " <> other
  | None -> "Complexity not documented"
```

### 4. **Documentation-Driven Testing**

```topos
-- Examples in documentation become automatic tests
doc "Safely divides two numbers"
doc params {
  dividend: "The number to be divided",
  divisor: "The number to divide by (must be non-zero)"
}
doc returns "Some result if divisor is non-zero, None otherwise"
doc examples """
  divide 10 2 == Some 5
  divide 10 0 == None
  divide 7 2 == Some 3.5
"""
doc properties {
  identity: "divide x 1 == Some x",
  zero_divisor: "divide x 0 == None",
  inverse: "divide x x == Some 1 when x != 0"
}
flow divide : Float -> Float -> Maybe Float
flow divide x y =
  if y == 0 then None else Some (x / y)

-- Compiler generates tests from examples and properties
test "divide_examples" =
  Introspect.examples divide
  |> List.map parse_example
  |> List.all run_example_test

test "divide_properties" = 
  Property.check $ Introspect.properties divide
```

### 5. **Interactive Documentation REPL**

```topos
-- Special REPL commands for documentation
repl> :doc List.map
"""
Transform the contents without changing the container structure

Parameters:
  f: Function to apply to each contained value  
  container: The container whose contents to transform

Returns: Container with transformed contents

Examples:
  List.map (+1) [1,2,3] == [2,3,4]

Complexity: O(n)
Category: Collections
"""

repl> :search "payment"
Found 3 items with tag 'payment':
  - process_payment : Account -> Payment -> Result Transaction Error
  - validate_payment : Payment -> Result Payment ValidationError
  - refund_payment : Transaction -> Result Refund Error

repl> :examples process_payment
Running examples for process_payment...
  ✓ Example 1: Valid payment processed successfully
  ✓ Example 2: Insufficient funds returns error
  ✓ Example 3: Invalid account returns error
All examples passed!

repl> :laws Mappable
Checking laws for Mappable trait...
  ✓ Identity law: map identity = identity
  ✓ Composition law: map (f . g) = map f . map g
Laws verified for: List, Maybe, Result, Tree, Process
```

### 6. **Documentation Inheritance and Composition**

```topos
-- Documentation can be inherited and extended
doc "Base collection operations"
doc abstract true
trait Collection c where
  doc "Check if collection is empty"
  is_empty : c a -> Bool
  
  doc "Get the number of elements"
  size : c a -> Natural

-- Inheriting documentation
doc extends Collection
doc "Ordered collection with index-based access"
trait IndexedCollection c where
  includes Collection
  
  doc "Get element at index, returning None if out of bounds"
  doc complexity "O(1) for arrays, O(n) for lists"
  at : Natural -> c a -> Maybe a

-- Documentation composition for composed functions
doc "Validate user data"
flow validate_user : User -> Result User Error

doc "Store user in database"  
flow store_user : User -> IO User

-- Composed function inherits combined documentation
doc compose [validate_user, store_user]
doc "Validates and stores user data atomically"
flow save_user = validate_user >> IO.lift >> (>>= store_user)
```

### 7. **Module-Level Documentation**

```topos
doc """
  Financial transaction processing module
  
  This module handles all financial operations including payments,
  refunds, and account management. All operations are immutable
  and follow PCI compliance standards.
"""
doc authors ["Team FinTech", "alice@company.com"]
doc license "MIT"
doc stability "stable"
doc internal false
module Finance = {
  doc "Core payment processing functionality"
  category Payment = {
    doc "Processes a payment transaction"
    export flow process : Payment -> Result Transaction Error
    
    doc "Validates payment details before processing"
    export flow validate : Payment -> Result Payment ValidationError
  }
  
  doc "Account management operations"
  category Account = {
    doc "Creates a new account with initial balance"
    export flow create : Text -> Money -> Account
    
    doc "Queries current account balance"
    export flow balance : Account -> Money
  }
}
```

### 8. **Documentation Enforcement Levels**

```topos
-- Compiler flags for documentation strictness
{-# DOC_LEVEL strict #-}  -- Everything must be documented
module StrictModule = { ... }

{-# DOC_LEVEL public #-}  -- Only public APIs need docs (default)
module NormalModule = { ... }

{-# DOC_LEVEL relaxed #-}  -- Documentation optional (for prototyping)
module PrototypeModule = { ... }

-- Conditional documentation requirements
doc required_if exported
flow internal_helper : a -> b  -- No doc needed if not exported

export flow public_api : a -> b  -- ERROR: Exported function needs doc
```

### 9. **Documentation Metadata and Search**

```topos
-- Documentation database built at compile time
module DocDB = {
  doc "Search all documentation by keyword"
  flow search : Text -> List DocEntry
  
  doc "Find all functions that work with a specific type"
  flow functions_for_type : Type -> List Function
  
  doc "Get all deprecated items with migration paths"
  flow deprecated_items : Unit -> List (Item, Migration)
  
  doc "Generate documentation graph showing relationships"
  flow dependency_graph : Module -> Graph DocNode
}

-- Generate documentation in multiple formats
flow generate_docs : Module -> Format -> IO Unit
flow generate_docs module format =
  match format
  | HTML -> generate_html module
  | Markdown -> generate_markdown module  
  | JSON -> generate_json module
  | Graph -> generate_graph module
```

### 10. **Type-Safe Documentation References**

```topos
-- Documentation can reference other items type-safely
doc "User authentication result"
doc see_also [User, validate_password, create_session]  -- Compiler verifies these exist
shape AuthResult = Success User | Failure AuthError

-- Cross-references are checked at compile time
doc "Processes user registration"
doc requires [validate_email, hash_password]  -- Must exist
doc provides [User, Session]  -- Must be correct types
flow register : Credentials -> Result User Error

-- Documentation contracts
doc contract {
  precondition: "email must be valid format",
  postcondition: "result.is_ok implies user.email == input.email",
  invariant: "user.id is unique"
}
flow create_user : Email -> Password -> Result User Error
```

### 11. **Documentation-Driven Development (DDD)**

```topos
-- Write documentation first, implementation later
doc "Calculates compound interest with monthly contributions"
doc params {
  principal: "Initial investment amount",
  rate: "Annual interest rate as decimal (0.05 for 5%)",
  years: "Investment period in years",
  monthly: "Monthly contribution amount"
}
doc returns "Final value after compound interest"
doc examples """
  compound 1000 0.05 10 100 == 16470.09
  compound 5000 0.07 5 0 == 7012.76
"""
flow compound : Money -> Float -> Natural -> Money -> Money
flow compound = undefined  -- Can compile with just docs!

-- Documentation stubs for TDD
doc stub "Not yet implemented"
flow future_feature : a -> b
flow future_feature = todo "Implement in version 2.0"
```

### 12. **Runtime Documentation Validation**

```topos
-- Validate documentation matches implementation
flow validate_docs : Module -> Result ValidationReport (List DocError)
flow validate_docs module =
  module.@@doc
  |> DocValidator.check_examples  -- Run all examples
  |> (>> DocValidator.check_properties)  -- Verify properties
  |> (>> DocValidator.check_complexity)  -- Benchmark complexity claims
  |> (>> DocValidator.check_references)  -- Verify all references exist

-- Documentation coverage metrics
flow coverage : Module -> DocCoverage
flow coverage module =
  { total: count_all_definitions module,
    documented: count_documented module,
    with_examples: count_with_examples module,
    with_properties: count_with_properties module,
    percentage: (documented / total) * 100
  }
```

### Key Documentation Features Summary:

1. **Mandatory Documentation**: Compiler enforces documentation for all public APIs
2. **Structured Format**: Documentation has defined fields (params, returns, examples, etc.)
3. **Runtime Introspection**: Query any documentation at runtime via `@@doc` operator
4. **Example Testing**: Documentation examples become executable tests
5. **REPL Integration**: Interactive documentation exploration in REPL
6. **Cross-References**: Type-safe references to other documented items
7. **Search Capabilities**: Built-in documentation database and search
8. **Multiple Formats**: Generate HTML, Markdown, JSON, or graph visualizations
9. **Documentation Inheritance**: Compose and extend documentation
10. **Validation**: Runtime verification that docs match implementation
11. **Coverage Metrics**: Track documentation completeness
12. **DDD Support**: Write docs first, implementation later

This design makes documentation not just a best practice but an integral part of the language, ensuring every piece of code is self-documenting and discoverable. The documentation becomes part of the program's metadata, available for both static analysis and runtime introspection.
