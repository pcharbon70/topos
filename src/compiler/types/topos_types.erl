%%%
%%% @doc Topos Type Representation
%%%
%%% Internal type representation for the Topos type inference engine.
%%% This module provides the core type constructors, fresh variable
%%% generation, and effect set operations.
%%%
%%% This is separate from AST type expressions to optimize for
%%% Algorithm W operations.
%%%
%%% @end
%%%
-module(topos_types).

%% Type construction
-export([
    tvar/1,
    tcon/1,
    tapp/2,
    tfun/3,
    trecord/2,
    ttuple/1,
    tvariant/1
]).

%% Fresh variable generation (stateless - explicit state threading)
-export([
    fresh_var/1,
    fresh_var_id/1
]).

%% Effect set operations
-export([
    empty_effects/0,
    singleton_effect/1,
    union_effects/2,
    normalize_effects/1,
    is_pure/1,
    effects_equal/2
]).

%% Type operations
-export([
    is_function_type/1,
    is_type_var/1,
    extract_function_effects/1,
    type_vars/1
]).

%%====================================================================
%% Type Definitions
%%====================================================================

-type type_var_id() :: pos_integer().

-type base_type() :: integer | float | string | atom | boolean | unit.

-type ty() :: {tvar, type_var_id()}                     % Type variable
            | {tcon, atom()}                            % Type constructor
            | {tapp, ty(), [ty()]}                      % Type application
            | {tfun, ty(), ty(), effect_set()}          % Function with effects
            | {trecord, [{atom(), ty()}], row_var()}    % Record type
            | {ttuple, [ty()]}                          % Tuple type
            | {tvariant, [{atom(), [ty()]}]}.           % Variant type

-type effect_set() :: {effect_set, [atom()]}.  % Normalized: sorted, no dups
-type row_var() :: type_var_id() | closed.     % Row variable or closed

-export_type([ty/0, type_var_id/0, effect_set/0, row_var/0, base_type/0]).

%%====================================================================
%% Type Construction Functions
%%====================================================================

%% @doc Create a type variable.
%%
%% Type variables represent unknown or polymorphic types during type inference.
%% They are identified by unique positive integers generated by the fresh
%% variable generator.
%%
%% @param Id A unique positive integer identifying the type variable
%% @returns A type variable `{tvar, Id}'
%%
%% @see fresh_var/1
%% @see fresh_var_id/1
%%
%% @example
%% ```
%% %% Create type variable α1
%% Alpha1 = topos_types:tvar(1).  %% → {tvar, 1}
%%
%% %% Type variables are typically generated fresh
%% State0 = topos_type_state:new(),
%% {Var, State1} = topos_types:fresh_var(State0).  %% → {{tvar, 1}, State1}
%% '''
-spec tvar(type_var_id()) -> ty().
tvar(Id) when is_integer(Id), Id > 0 ->
    {tvar, Id}.

%% @doc Create a type constructor (constant type).
%%
%% Type constructors represent named types like `integer', `string', `boolean',
%% or user-defined types like `List', `Maybe', etc. They can be applied to
%% type arguments using `tapp/2'.
%%
%% @param Name The name of the type constructor as an atom
%% @returns A type constructor `{tcon, Name}'
%%
%% @see tapp/2
%%
%% @example
%% ```
%% %% Built-in type constructors
%% IntType = topos_types:tcon(integer).     %% → {tcon, integer}
%% StringType = topos_types:tcon(string).   %% → {tcon, string}
%%
%% %% User-defined type constructors
%% ListCon = topos_types:tcon('List').      %% → {tcon, 'List'}
%% MaybeCon = topos_types:tcon('Maybe').    %% → {tcon, 'Maybe'}
%% '''
-spec tcon(atom()) -> ty().
tcon(Name) when is_atom(Name) ->
    {tcon, Name}.

%% @doc Create a type application (parameterized type).
%%
%% Type applications represent parameterized types by applying a type constructor
%% to zero or more type arguments. Examples include `List<Int>', `Maybe<String>',
%% or `Map<String, Int>'.
%%
%% @param Constructor The type constructor to apply (typically a `tcon')
%% @param Args List of type arguments to apply to the constructor
%% @returns A type application `{tapp, Constructor, Args}'
%%
%% @see tcon/1
%%
%% @example
%% ```
%% %% List<Int>
%% ListInt = topos_types:tapp(
%%     topos_types:tcon('List'),
%%     [topos_types:tcon(integer)]
%% ).
%%
%% %% Maybe<String>
%% MaybeStr = topos_types:tapp(
%%     topos_types:tcon('Maybe'),
%%     [topos_types:tcon(string)]
%% ).
%%
%% %% Map<String, Int>
%% MapStrInt = topos_types:tapp(
%%     topos_types:tcon('Map'),
%%     [topos_types:tcon(string), topos_types:tcon(integer)]
%% ).
%% '''
-spec tapp(ty(), [ty()]) -> ty().
tapp(Constructor, Args) when is_list(Args) ->
    {tapp, Constructor, Args}.

%% @doc Create a function type with effect tracking.
%%
%% Function types represent transformations from one type to another, with
%% an associated effect set tracking computational side effects. Pure functions
%% have an empty effect set, while impure functions list their effects.
%%
%% @param From The parameter type (domain)
%% @param To The return type (codomain)
%% @param Effects The effect set tracking side effects (use `empty_effects()' for pure)
%% @returns A function type `{tfun, From, To, Effects}'
%%
%% @see empty_effects/0
%% @see singleton_effect/1
%% @see union_effects/2
%%
%% @example
%% ```
%% %% Pure function: Int -> String
%% PureFunc = topos_types:tfun(
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string),
%%     topos_types:empty_effects()
%% ).
%%
%% %% Impure function with IO effect: String -> Unit <io>
%% IoFunc = topos_types:tfun(
%%     topos_types:tcon(string),
%%     topos_types:tcon(unit),
%%     topos_types:singleton_effect(io)
%% ).
%% '''
-spec tfun(ty(), ty(), effect_set()) -> ty().
tfun(From, To, Effects) ->
    {tfun, From, To, Effects}.

%% @doc Create a record type with row polymorphism.
%%
%% Record types represent named field collections with optional row polymorphism
%% for extensibility. A closed record has a fixed set of fields, while an open
%% record (with a row variable) can be extended with additional fields.
%%
%% Validates that all field names are unique. Raises an error if duplicates exist.
%%
%% @param Fields List of field name-type pairs `{FieldName, FieldType}'
%% @param RowVar Row variable ID for extensibility, or `closed' for fixed fields
%% @returns A record type `{trecord, Fields, RowVar}'
%%
%% @see tvar/1
%%
%% @example
%% ```
%% %% Closed record: {x: Int, y: Int}
%% Point = topos_types:trecord(
%%     [{x, topos_types:tcon(integer)}, {y, topos_types:tcon(integer)}],
%%     closed
%% ).
%%
%% %% Open record with row variable: {x: Int, y: Int | ρ}
%% ExtensiblePoint = topos_types:trecord(
%%     [{x, topos_types:tcon(integer)}, {y, topos_types:tcon(integer)}],
%%     1  %% Row variable α1
%% ).
%% '''
-spec trecord([{atom(), ty()}], row_var()) -> ty().
trecord(Fields, RowVar) when is_list(Fields) ->
    % Validate no duplicate field names
    FieldNames = [Name || {Name, _Type} <- Fields],
    case length(FieldNames) =:= length(lists:usort(FieldNames)) of
        true -> {trecord, Fields, RowVar};
        false ->
            Duplicates = find_duplicates(FieldNames),
            error({duplicate_record_fields, Duplicates})
    end.

%% @doc Create a tuple type.
%%
%% Tuple types represent fixed-size, ordered collections of heterogeneous elements.
%% Each element can have a different type.
%%
%% @param Elements List of element types in order
%% @returns A tuple type `{ttuple, Elements}'
%%
%% @example
%% ```
%% %% Empty tuple (unit type)
%% Unit = topos_types:ttuple([]).
%%
%% %% Pair: (Int, String)
%% Pair = topos_types:ttuple([
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string)
%% ]).
%%
%% %% Triple: (Int, String, Bool)
%% Triple = topos_types:ttuple([
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string),
%%     topos_types:tcon(boolean)
%% ]).
%% '''
-spec ttuple([ty()]) -> ty().
ttuple(Elements) when is_list(Elements) ->
    {ttuple, Elements}.

%% @doc Create a variant type (sum type/tagged union).
%%
%% Variant types represent alternatives where a value can be one of several
%% constructors, each with its own payload types. Also known as algebraic
%% data types or sum types.
%%
%% Validates that all constructor names are unique. Raises an error if duplicates exist.
%%
%% @param Constructors List of constructor definitions `{Name, ArgTypes}'
%% @returns A variant type `{tvariant, Constructors}'
%%
%% @example
%% ```
%% %% Maybe type: Some a | None
%% State0 = topos_type_state:new(),
%% {Alpha, _State1} = topos_types:fresh_var(State0),
%% Maybe = topos_types:tvariant([
%%     {'Some', [Alpha]},
%%     {'None', []}
%% ]).
%%
%% %% Result type: Ok a | Error String
%% Result = topos_types:tvariant([
%%     {'Ok', [Alpha]},
%%     {'Error', [topos_types:tcon(string)]}
%% ]).
%%
%% %% Color type: Red | Green | Blue
%% Color = topos_types:tvariant([
%%     {'Red', []},
%%     {'Green', []},
%%     {'Blue', []}
%% ]).
%% '''
-spec tvariant([{atom(), [ty()]}]) -> ty().
tvariant(Constructors) when is_list(Constructors) ->
    % Validate no duplicate constructor names
    ConstructorNames = [Name || {Name, _Args} <- Constructors],
    case length(ConstructorNames) =:= length(lists:usort(ConstructorNames)) of
        true -> {tvariant, Constructors};
        false ->
            Duplicates = find_duplicates(ConstructorNames),
            error({duplicate_variant_constructors, Duplicates})
    end.

%%====================================================================
%% Fresh Variable Generation
%%====================================================================

%% These functions explicitly thread state through computations,
%% making them functional, testable, and thread-safe.
%% State is managed by topos_type_state module.

%% @doc Generate a fresh type variable with explicit state threading.
%%
%% Creates a new type variable with a guaranteed unique ID. This function
%% uses explicit state threading to ensure functional purity and thread safety.
%% Each call increments the internal counter and returns both the new variable
%% and the updated state.
%%
%% Essential for type inference algorithms like Algorithm W, where fresh
%% variables represent unknown types that will be unified during inference.
%%
%% @param State The current type state (from `topos_type_state:new()' or previous call)
%% @returns Tuple `{TypeVariable, NewState}' where TypeVariable is `{tvar, Id}'
%%
%% @see fresh_var_id/1
%% @see tvar/1
%%
%% @example
%% ```
%% %% Generate fresh variables with state threading
%% State0 = topos_type_state:new(),
%% {Var1, State1} = topos_types:fresh_var(State0),  %% → {{tvar, 1}, State1}
%% {Var2, State2} = topos_types:fresh_var(State1),  %% → {{tvar, 2}, State2}
%% {Var3, State3} = topos_types:fresh_var(State2).  %% → {{tvar, 3}, State3}
%%
%% %% Each variable has a unique ID
%% Var1 =/= Var2 =/= Var3  %% → true
%% '''
-spec fresh_var(topos_type_state:state()) -> {ty(), topos_type_state:state()}.
fresh_var(State) ->
    topos_type_state:fresh_var(State).

%% @doc Generate a fresh type variable ID with explicit state threading.
%%
%% Similar to `fresh_var/1' but returns only the numeric ID instead of
%% a complete type variable structure. Useful when you need to construct
%% types manually or track variable IDs separately.
%%
%% @param State The current type state (from `topos_type_state:new()' or previous call)
%% @returns Tuple `{VarId, NewState}' where VarId is a positive integer
%%
%% @see fresh_var/1
%% @see tvar/1
%%
%% @example
%% ```
%% %% Generate fresh variable IDs
%% State0 = topos_type_state:new(),
%% {Id1, State1} = topos_types:fresh_var_id(State0),  %% → {1, State1}
%% {Id2, State2} = topos_types:fresh_var_id(State1),  %% → {2, State2}
%%
%% %% Manually construct type variables from IDs
%% Var1 = topos_types:tvar(Id1),  %% → {tvar, 1}
%% Var2 = topos_types:tvar(Id2).  %% → {tvar, 2}
%% '''
-spec fresh_var_id(topos_type_state:state()) -> {type_var_id(), topos_type_state:state()}.
fresh_var_id(State) ->
    topos_type_state:fresh_var_id(State).

%%====================================================================
%% Effect Set Operations
%%====================================================================

%% @doc Create an empty effect set (pure computation).
%%
%% Empty effect sets represent pure computations with no side effects.
%% Pure functions have no observable effects beyond computing their result.
%%
%% @returns An empty effect set `{effect_set, []}'
%%
%% @see singleton_effect/1
%% @see union_effects/2
%% @see is_pure/1
%%
%% @example
%% ```
%% %% Create a pure function type
%% PureFunc = topos_types:tfun(
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string),
%%     topos_types:empty_effects()
%% ).
%% '''
-spec empty_effects() -> effect_set().
empty_effects() ->
    {effect_set, []}.

%% @doc Create an effect set with a single effect.
%%
%% Creates a normalized effect set containing exactly one effect.
%% Common effects include: `io' (I/O operations), `state' (stateful
%% computation), `error' (error handling), `async' (asynchronous).
%%
%% @param Effect The effect name as an atom
%% @returns An effect set containing the single effect
%%
%% @see empty_effects/0
%% @see union_effects/2
%%
%% @example
%% ```
%% %% Function with IO effect
%% IoFunc = topos_types:tfun(
%%     topos_types:tcon(string),
%%     topos_types:tcon(unit),
%%     topos_types:singleton_effect(io)
%% ).
%%
%% %% Function with state effect
%% StateFunc = topos_types:tfun(
%%     topos_types:tcon(integer),
%%     topos_types:tcon(integer),
%%     topos_types:singleton_effect(state)
%% ).
%% '''
-spec singleton_effect(atom()) -> effect_set().
singleton_effect(Effect) when is_atom(Effect) ->
    {effect_set, [Effect]}.

%% @doc Compute the union of two effect sets.
%%
%% Merges two effect sets into a single normalized set containing all
%% effects from both inputs. The result is automatically sorted and
%% deduplicated.
%%
%% Used when combining effects from multiple computations, such as
%% sequencing operations or composing functions.
%%
%% @param E1 First effect set
%% @param E2 Second effect set
%% @returns Union of both effect sets, normalized (sorted, no duplicates)
%%
%% @see normalize_effects/1
%%
%% @example
%% ```
%% %% Combine IO and state effects
%% IoEffects = topos_types:singleton_effect(io),
%% StateEffects = topos_types:singleton_effect(state),
%% Combined = topos_types:union_effects(IoEffects, StateEffects).
%% %% → {effect_set, [io, state]}
%%
%% %% Union with duplicates automatically deduplicates
%% E1 = {effect_set, [io, state]},
%% E2 = {effect_set, [state, error]},
%% Union = topos_types:union_effects(E1, E2).
%% %% → {effect_set, [error, io, state]}
%% '''
-spec union_effects(effect_set(), effect_set()) -> effect_set().
union_effects({effect_set, E1}, {effect_set, E2}) ->
    % Merge and normalize (sort + deduplicate)
    normalize_effects(E1 ++ E2).

%% @doc Normalize a list of effects into a canonical effect set.
%%
%% Converts a plain list of effect atoms into a normalized effect set
%% by sorting and removing duplicates. Effect sets are always kept in
%% canonical form to enable fast equality checks.
%%
%% @param Effects List of effect atoms (may contain duplicates)
%% @returns Normalized effect set with effects sorted and deduplicated
%%
%% @see union_effects/2
%%
%% @example
%% ```
%% %% Normalize a list with duplicates
%% Effects = topos_types:normalize_effects([io, state, io, error, state]).
%% %% → {effect_set, [error, io, state]}
%%
%% %% Empty list becomes empty effect set
%% Pure = topos_types:normalize_effects([]).
%% %% → {effect_set, []}
%% '''
-spec normalize_effects([atom()]) -> effect_set().
normalize_effects(Effects) when is_list(Effects) ->
    % Sort and remove duplicates in one pass
    % lists:usort already sorts, so no need for separate lists:sort
    {effect_set, lists:usort(Effects)}.

%% @doc Check if an effect set is empty (represents pure computation).
%%
%% Returns `true' if the effect set contains no effects, indicating
%% a pure computation with no side effects.
%%
%% @param EffectSet The effect set to check
%% @returns `true' if the set is empty, `false' otherwise
%%
%% @see empty_effects/0
%%
%% @example
%% ```
%% %% Pure computation
%% ?assert(topos_types:is_pure(topos_types:empty_effects())).
%%
%% %% Impure computation
%% ?assertNot(topos_types:is_pure(topos_types:singleton_effect(io))).
%% '''
-spec is_pure(effect_set()) -> boolean().
is_pure({effect_set, []}) -> true;
is_pure({effect_set, _}) -> false.

%% @doc Check if two effect sets are equal.
%%
%% Since effect sets are always normalized (sorted, no duplicates),
%% equality can be checked with simple term comparison.
%%
%% @param E1 First effect set
%% @param E2 Second effect set
%% @returns `true' if the sets contain exactly the same effects
%%
%% @example
%% ```
%% E1 = topos_types:normalize_effects([io, state]),
%% E2 = topos_types:normalize_effects([state, io]),
%% ?assert(topos_types:effects_equal(E1, E2)).
%%
%% E3 = topos_types:singleton_effect(error),
%% ?assertNot(topos_types:effects_equal(E1, E3)).
%% '''
-spec effects_equal(effect_set(), effect_set()) -> boolean().
effects_equal({effect_set, E1}, {effect_set, E2}) ->
    E1 =:= E2.  % Already normalized, so direct comparison

%%====================================================================
%% Type Operations
%%====================================================================

%% @doc Check if a type is a function type.
%%
%% Returns `true' if the type is a function type (has structure `{tfun, _, _, _}'),
%% `false' otherwise. Useful for pattern matching and type checking.
%%
%% @param Type The type to check
%% @returns `true' if the type is a function type, `false' otherwise
%%
%% @see tfun/3
%% @see extract_function_effects/1
%%
%% @example
%% ```
%% %% Function type
%% FuncType = topos_types:tfun(
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string),
%%     topos_types:empty_effects()
%% ),
%% ?assert(topos_types:is_function_type(FuncType)).
%%
%% %% Non-function type
%% IntType = topos_types:tcon(integer),
%% ?assertNot(topos_types:is_function_type(IntType)).
%% '''
-spec is_function_type(ty()) -> boolean().
is_function_type({tfun, _, _, _}) -> true;
is_function_type(_) -> false.

%% @doc Check if a type is a type variable.
%%
%% Returns `true' if the type is a type variable (has structure `{tvar, _}'),
%% `false' otherwise. Type variables represent unknown types during inference.
%%
%% @param Type The type to check
%% @returns `true' if the type is a type variable, `false' otherwise
%%
%% @see tvar/1
%% @see fresh_var/1
%%
%% @example
%% ```
%% %% Type variable
%% Var = topos_types:tvar(1),
%% ?assert(topos_types:is_type_var(Var)).
%%
%% %% Concrete type
%% IntType = topos_types:tcon(integer),
%% ?assertNot(topos_types:is_type_var(IntType)).
%% '''
-spec is_type_var(ty()) -> boolean().
is_type_var({tvar, _}) -> true;
is_type_var(_) -> false.

%% @doc Extract the effect set from a function type.
%%
%% If the type is a function type, returns `{ok, Effects}' where `Effects'
%% is the effect set. If the type is not a function, returns `error'.
%%
%% @param Type The type to extract effects from
%% @returns `{ok, EffectSet}' if function type, `error' otherwise
%%
%% @see tfun/3
%% @see is_function_type/1
%%
%% @example
%% ```
%% %% Extract effects from function type
%% FuncType = topos_types:tfun(
%%     topos_types:tcon(integer),
%%     topos_types:tcon(string),
%%     topos_types:singleton_effect(io)
%% ),
%% {ok, Effects} = topos_types:extract_function_effects(FuncType).
%% %% → {ok, {effect_set, [io]}}
%%
%% %% Non-function type returns error
%% IntType = topos_types:tcon(integer),
%% error = topos_types:extract_function_effects(IntType).
%% '''
-spec extract_function_effects(ty()) -> {ok, effect_set()} | error.
extract_function_effects({tfun, _, _, Effects}) ->
    {ok, Effects};
extract_function_effects(_) ->
    error.

%% @doc Collect all type variables appearing in a type.
%%
%% Recursively traverses a type structure and collects all type variable IDs
%% into a set. Includes variables from function parameters/returns, type
%% applications, tuples, records (including row variables), and variants.
%%
%% Essential for type operations like generalization (determining which
%% variables to quantify) and occurs checks (detecting circular types).
%%
%% @param Type The type to collect variables from
%% @returns Set of type variable IDs found in the type
%%
%% @see tvar/1
%% @see fresh_var/1
%%
%% @example
%% ```
%% %% Simple type variable
%% Var = topos_types:tvar(1),
%% Vars = topos_types:type_vars(Var).
%% %% → set containing 1
%%
%% %% Function type: α -> β
%% State0 = topos_type_state:new(),
%% {Alpha, State1} = topos_types:fresh_var(State0),  %% → {tvar, 1}
%% {Beta, _State2} = topos_types:fresh_var(State1),  %% → {tvar, 2}
%% FuncType = topos_types:tfun(Alpha, Beta, topos_types:empty_effects()),
%% FuncVars = topos_types:type_vars(FuncType).
%% %% → set containing 1 and 2
%%
%% %% Concrete type (no variables)
%% IntType = topos_types:tcon(integer),
%% NoVars = topos_types:type_vars(IntType).
%% %% → empty set
%% '''
-spec type_vars(ty()) -> sets:set(type_var_id()).
type_vars(Type) ->
    type_vars_acc(Type, sets:new(), 0).

%% Internal function with depth tracking to prevent stack overflow
-spec type_vars_acc(ty(), sets:set(type_var_id()), non_neg_integer()) -> sets:set(type_var_id()).
type_vars_acc(_Type, _Acc, Depth) when Depth > 100 ->
    MaxDepth = topos_compiler_utils:get_max_type_depth(),
    error(topos_type_error:type_depth_exceeded(Depth, MaxDepth));

type_vars_acc({tvar, Id}, Acc, _Depth) ->
    sets:add_element(Id, Acc);

type_vars_acc({tcon, _}, Acc, _Depth) ->
    Acc;

type_vars_acc({tapp, Con, Args}, Acc, Depth) ->
    Acc1 = type_vars_acc(Con, Acc, Depth + 1),
    lists:foldl(
        fun(Arg, A) -> type_vars_acc(Arg, A, Depth + 1) end,
        Acc1,
        Args
    );

type_vars_acc({tfun, From, To, _Effects}, Acc, Depth) ->
    Acc1 = type_vars_acc(From, Acc, Depth + 1),
    type_vars_acc(To, Acc1, Depth + 1);

type_vars_acc({trecord, Fields, RowVar}, Acc, Depth) ->
    Acc1 = lists:foldl(
        fun({_Name, FieldType}, A) -> type_vars_acc(FieldType, A, Depth + 1) end,
        Acc,
        Fields
    ),
    case RowVar of
        closed -> Acc1;
        VarId when is_integer(VarId) -> sets:add_element(VarId, Acc1)
    end;

type_vars_acc({ttuple, Elements}, Acc, Depth) ->
    lists:foldl(
        fun(Elem, A) -> type_vars_acc(Elem, A, Depth + 1) end,
        Acc,
        Elements
    );

type_vars_acc({tvariant, Constructors}, Acc, Depth) ->
    lists:foldl(
        fun({_Name, ArgTypes}, A) ->
            lists:foldl(
                fun(ArgType, A2) -> type_vars_acc(ArgType, A2, Depth + 1) end,
                A,
                ArgTypes
            )
        end,
        Acc,
        Constructors
    ).

%%====================================================================
%% Internal Functions
%%====================================================================

%% @doc Find duplicate elements in a list
%% Returns a list of elements that appear more than once
-spec find_duplicates([atom()]) -> [atom()].
find_duplicates(List) ->
    find_duplicates(List, #{}, []).

find_duplicates([], _Seen, Duplicates) ->
    lists:usort(Duplicates);
find_duplicates([Item | Rest], Seen, Duplicates) ->
    case maps:is_key(Item, Seen) of
        true ->
            % Already seen, it's a duplicate
            find_duplicates(Rest, Seen, [Item | Duplicates]);
        false ->
            % First occurrence
            find_duplicates(Rest, maps:put(Item, true, Seen), Duplicates)
    end.
